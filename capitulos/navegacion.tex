\chapter{Navegación}\label{chapter:navegacion}

En este capítulo se expone el desarrollo referente a la navegación dentro del ecosistema ROS. En él se describen las características de navegación del paquete de navegación y sus posibilidades.

Este capítulo trata de abordar el aspecto de la navegación desde el punto de vista de la utilidad, pasando por su fundamento teórico y sin dejar de lado su aplicación en el robot Pioneer 3 AT.

Por tanto, se exponen algunos ejemplos de configuraciones para la navegación, sin embargo, la configuración final del robot y la discusión sobre la misma se abordará en el capítulo \ref{chapter:implementacion}, donde hablaremos de su implementación más en detalle.

\section{Navigation Stack}\label{section:navigation_stack}
Dentro de las funcionalidades de ROS ya hemos comentado que existen los metapaquetes o "Stacks", que son grupos de paquetes de software que todos juntos ofrece una funcionalidad.

El paquete de navegación de ROS \cite{navigation-ros} se define como un paquete de navegación en dos dimensiones que toma información dela odometría, de los sensores y de un punto de meta y dirige el robot mediante comandos de velocidad seguros.

La navegación se basa en el uso de "Mapas de coste'' y planificación global y local de trayectorias.

Por un lado, el sistema hace un mapa de coste global que tiene encuentra información de los sensores y la posibilidad de cargar un mapa previo. A este mapa se incorporan los obstáculos que permanecen estáticos durante más tiempo y en base a este se realizan los cálculos de trayectoria global.

Por otro lado, el sistema realiza un mapa de coste local, que analiza los obstáculos más cercanos al robot en cada momento. A este mapa se incorpora la información de los sensores sobre cualquier tipo de obstáculo detectado. En base a este mapa se realizan los cálculos de trayectoria local que llevará el control de la navegación reactiva del robot.

RELLENAR ALGO MAS

\subsection{Funcionamiento}

El paquete de navegación se basa en diferentes nodos que interactúan para dirigir el robot hasta un punto en el mapa indicado como meta.

Este sistema utiliza un mapa de obstáculos estáticos (global\_costmap), un mapa de obstáculo locales (local\_costmap), un nodo de cálculo de trayectoria global (globa\_planner), un nodo de cálculo de trayectoria local (local\_planner) y mecanismos de recuperación de trayectoria (recovery\_behaviors).

\begin{figure}[!htp]
\centering
\includegraphics[width=\textwidth]{figuras/navigation-ros.png}
\caption{Diagrama de funcionamiento del Navigation Stack \cite{navigationsetup}}
\label{fig:navigation-ros}
\end{figure}

En el diagrama mostrado en la figura \ref{fig:navigation-ros} podemos ver una representación de los nodos y mensajes utilizados por el paquete de navegación así como la información externa y opcional que se precisa.

Como puede apreciarse, los sensores, la odometría y el ajuste de las transfromadas entre cada uno de los sistemas de coordenadas son específicos de cada plataforma robótica. La ejecución principal se centra en el nodo \textit{move\_base} **referencia**, que es el ecargado de realizar los movimientos acorde a la información que aportan los mapas y los planificadores de trayectoria.

Por último indicar que el paquete de navegación no precisa de un mapa pregrabado para funcionar. Puede utilizarse un mapa si se precisa y cargarlo mediante un nodo externo como \textit{map\_server} o generarlo simultáneamente a la navegación mediante \textit{slam\_gmappig} (Subsección \ref{subsection:slam_gmapping}).

El uso de un nodo de localización del robot en el mapa, como AMCL (Adaptive Monte Carlo Localization), será preciso cuando se utilice un mapa pregrabado para conocer la posición inicial del robot y posicionarlo correctamente dentro del mismo (Sección \ref{section:amcl}).

\subsection{Requisitos para la navegación}
El sistema de navegación de ROS está diseñado para ser flexible, altamente configurable y adaptable a muchos tipos de robots. Sin embargo requiere de ciertos requisitos para poder se integrado. A continuación se describe cada uno de los requisitos aplicados al robot Pioneer 3 AT utilizado en este trabajo.

\textbf{Odometría}\\
El sistema de navegación requiere de un robot que publique información sobre la odometría del robot en mensajes de tipo \textit{nav\_msgs/Odometry}.

En el robot Pioneer 3 AT y gracias al paquete RosAria (Subsección \ref{subsection:rosaria}) obtenemos la información de los enconders del robot convertida en datos de odometría a través del topic \textit{pose}.

\textbf{Movimientos}\\
El sistema de navegación requiere que el robot sea controlable a través de comandos de velocidad de tipo \textit{geometry\_msgs/Twist}.

En el robot Pioneer 3 AT y gracias al paquete RosAria (Subsección \ref{subsection:rosaria}) podemos mover nuestro robot con comandos de velocidad publicandolos al topic \textit{cmd\_vel}.

\textbf{Sensores}\\
Los tipos de sensores que pueden utilizarse en la navegación son variados, el requisito que deben cumplir para poder integrarse en el sistema de navegación es que publiquen información de tipo \textit{sensor\_msgs/LaserScan} o \textit{sensor\_msgs/PointCloud2}.

Con los nodos descritos anteiormente, podemos obtener información de este tipo para el sensor Kinect (Subsección \ref{subsection:kinect})y para el sensor Láser (Subsección \ref{subsection:sicklms100}). El nodo \textit{freenect\_stack} publica infomación de la nube de puntos a través del topic \textit{camera/depth/points} y el nodo \textit{LMS1xx} lo hace a través del topic \textit{scan}.

\textbf{Transformadas}\\
Es necesario que toda la información esté estructurada geométricamente para que el sistema de navegación pueda realizar los cálculos pertinentes. Se requiere información de los sistemas de coordenadas de cada sensor, de la base del robot y de la odometría.

Cada uno de los nodos descritos con anterioridad publican diferentes \textit{frames} que sirven para este propósito. Estos \textit{frames} (\textit{odom, base\_link, laser, camera\_link}) relacionados mediante transformadas estáticas como se describió en la subsección \ref{subsection:integracion_hardware}, proporcionan la información necesaria.

\subsection{Configuración de la navegación}
Hablar sobre los archivos necesarios .yaml y los launchfiles. de momento navegación con mapa y explicación.

Aunque se explicará más adelante, una vez explicados los requisitos para utilizar el paquete de navegación es necesario explicar cual es la configuración necesaria para hacer que el sistema funcione.

En primer lugar, para facilitar la comprensión, suponemos que disponemos de un mapa del entorno en el que se va a desplazar nuestro robot y que disponemos de tan solo un sensor láser para realizar la navegación.

Comenzamos por la configuración de los llamados Costmaps, esto es, mapas que van almacenar los obstáculos del entorno del robot. Disponemos de global\_costmap y local\_costmap como dijimos antes y parte de la configuración de estos será compartida, por tanto debemos crear un archivo de parámetros comunes \textit{costmap\_common\_params.yaml}.

\begin{code}[!htp]
\begin{lstlisting}[style=launch]
obstacle_range: 6.0
raytrace_range: 6.5
footprint: [ [0.254, -0.230], [-0.254, -0.230], [-0.254, 0.230], [0.254, 0.230] ]
inflation_radius: 0.5

observation_sources: laser_scan_sensor

laser_scan_sensor: {sensor_frame: laser, data_type: LaserScan, topic: /scan, marking: true, clearing: true}
\end{lstlisting}
\caption{Ejemplo de \textit{costmap\_common\_params.yaml}}
\end{code}

Como vemos, configuramos parámetros como la forma de nuestro robot, el radio de seguridad de los obstáculos, el rango de incorporación de obstáculos y los sensores.

A continuación creamos el archivo e configuración de nuestro mapa global \textit{global\_costmap.yaml}.

\begin{code}[!htp]
\begin{lstlisting}[style=launch]
global_costmap:
  global_frame: /map
  robot_base_frame: base_link
  update_frequency: 5.0
  static_map: true
\end{lstlisting}
\caption{Ejemplo de \textit{global\_costmap.yaml}}
\end{code}

En este archivo vemos como este "mapa de coste" permanece estático y anclado al eje de coordenadas del mapa.

El mapa de navegación local o reactiva es similar, aunque ne este caso el mapa tendrá unas dimensiones preestablecidas y se moverá con el robot.

\begin{code}[!htp]
\begin{lstlisting}[style=launch]
local_costmap:
  global_frame: odom
  robot_base_frame: base_link
  update_frequency: 5.0
  publish_frequency: 2.0
  static_map: false
  rolling_window: true
  width: 6.0
  height: 6.0
  resolution: 0.05
\end{lstlisting}
\caption{Ejemplo de \textit{local\_costmap.yaml}}
\end{code}

La configuración básica del planificador local se guardará en un archivo  \textit{base\_local\_planner\_params.yaml}.

\begin{code}[!htp]
\begin{lstlisting}[style=launch]
TrajectoryPlannerROS:
  max_vel_x: 0.45
  min_vel_x: 0.1
  max_vel_theta: 1.0
  min_in_place_vel_theta: 0.4

  acc_lim_theta: 3.2
  acc_lim_x: 2.5
  acc_lim_y: 2.5

  holonomic_robot: true
\end{lstlisting}
\caption{Ejemplo de \textit{local\_costmap.yaml}}
\end{code}

También debemos indicar la configuración del planificador global en \textit{global\_planner\_params.yaml}

\begin{code}[!htp]
\begin{lstlisting}[style=launch]
GlobalPlanner:
  old_navfn_behavior: false
  use_quadratic: true
  use_dijkstra: flase
  use_grid_path: false
\end{lstlisting}
\caption{Ejemplo de \textit{global\_planner\_params.yaml}}
\end{code}

Aquí podemos definir el cálculo de trayectorias siguiendo aproximaciones cuadráticas, basadas en ocupación de celdas, tipo A* o Dijkstra (Se hablará de cada una en la sección \ref{section:global_planner}).

Para finalizar, debemos ejecutar el nodo \textit{move\_base} con las configuraciones descritas anteriormente, así como el mapa y el nodo de localización AMCL.

\begin{code}[!htp]
\begin{lstlisting}[style=launch]
<launch>
    <!-- Run the map server -->
    <node name="map_server" pkg="map_server" type="map_server" args="$(find pioneer_utils)/maps/floor_zero-map.yaml"/>

    <!--- Run AMCL -->
    <include file="$(find pioneer_utils)/navigation/common/amcl.launch"/>
	
	<node pkg="move_base" type="move_base" respawn="false" name="move_base" output="screen">
        <rosparam file="$(find pioneer_utils)/navigation/common/costmap_common_params_p3at.yaml" command="load" ns="global_costmap" />
        <rosparam file="$(find pioneer_utils)/navigation/common/costmap_common_params_p3at.yaml" command="load" ns="local_costmap" />
        <rosparam file="$(find pioneer_utils)/navigation/common/local_costmap_params.yaml" command="load" />
        <rosparam file="$(find pioneer_utils)/navigation/global_navigation/global_costmap_params.yaml" command="load" />
        <rosparam file="$(find pioneer_utils)/navigation/common/base_local_planner_params.yaml" command="load"/>
        <rosparam file="$(find pioneer_utils)/navigation/common/global_planner_params.yaml" command="load" />
    </node>
</launch>false
\end{lstlisting}
\caption{Ejemplo de \textit{robot\_navigation.launch}}
\end{code}

La representación visual de ambos costmaps, el área del robot (footprint), el haz láser y el modelo de robot pueden observarse mediante RViz, tal y como muestra la figura \ref{fig:rviz_navigation}.

\begin{figure}[!htp]
\centering
\includegraphics[width=0.8\textwidth]{figuras/rviz_navigation.png}
\caption{Visualización de costmaps, sensor láser y modelo del robot en RViz.}
\label{fig:rviz_navigation}
\end{figure}

Este primer ajuste no tiene en cuenta muchos factores concretos de la navegación en el robot Pioneer 3 AT, como pueda ser la disposición correcta de los sensores, los ajustes de actualización de los mapas, el rango de los sensores o las interferencias de información que se incorporan o borran en los costmaps. Estos detalles se presentarán en la implementación del sistema (Capítulo \ref{chapter:implementacion}).

\section{SLAM}
La técnica de SLAM (Simultaneous Localization And Mapping) es una técnica muy utilizada en robótica para construir un mapa de un etorno que es desconocido al mismo tiempo que se estima la posición del robot en el mismo.

Esta técnica presenta dificultades como la imperfección de los sensores, la imperfección del sistema de locomoción el robot, la repetitividad de las medidas... Además de que la localización y el mapeado simultáneo de un entorno son dos problemas que están intrínsecamente acoplados \cite{puente2012probabilistic}. Es por ello que se utilizan modos probabilísticos como la relga de Bayes.

\textbf{Principales algoritmos}\\
Los principales algoritmos para realizar los cálculos pababilísticos en técnicas de SLAM son los sigientes:

\begin{itemize}
\item Filtro extendido de Kalman: Es uno de los métodos más extendidos en la técnica del SLAM por ofrecer resultados satisfactorios a pesar de sus problemas de estimación \cite{rodriguez2006consistency}. Esta ha sido la técnica utilizada de facto hasta a aparición del FastSLAM \cite{montemerlo2002fastslam}.

\item Mapas de ocupación de celdillas: Se basa en discretizar el espacio dividiéndolo en unidades de tamaño predefinido que se clasifican como ocupadas o vacías con un determinado nivel de confianza o probabilidad. La precisión (mayor cuanto más fina es la división del espacio), permite que el algoritmo de localización empleado acumule errores reducidos a lo largo de intervalos prolongados de tiempo. Su mayor desventaja de estos métodos es la pérdida de potencia que se deriva de no tener en cuenta la incertidumbre asociada a la posición del robot, lo cual origina que su capacidad para cerrar bucles correctamente se vea mermada \cite{collins2007occupancy}.
\end{itemize}

\subsubsection{slam\_gmapping en ROS}\label{subsection:slam_gmapping}
GMapping es una librería perteneciente al proyecto OpenSLAM \cite{openslam} que utiliza la técnica SLAM Grid Mapping, basada en la generación de mapas mediante la ocupación de celdillas utilizando un filtro de partículas \cite{grisetti2007improved}.

En ROS se integra bajo el paquete gmapping \url{http://wiki.ros.org/gmapping} que no es más que un wrapper de OpenSLAM adaptando su interfaz.

Para crear mapas utilizando slam\_gampping precisamos de nuestro robot configurado para leer su odometría un sensor capaz de ofrecernos información de tipo \textit{sensor\_msgs/LaserScan}.

Existen muchos parámetros para ajustar el proceso de SLAM en este nodo, sin embargo en este caso nos servimos de la configuración utilizada por el paquete \textit{p2os} por ofrecer unos resultados más que aceptables:

\begin{code}[!htp]
\begin{lstlisting}[style=launch]
<launch>
	<node pkg="gmapping" type="slam_gmapping" name="slam_gmapping" args="/scan">
		<param name="delta" type="double" value="0.05" />
		<param name="temporalUpdate" type="double" value="2.5" />
		<param name="xmin" type="double" value="-2" />
		<param name="xmax" type="double" value="2" />
		<param name="ymin" type="double" value="-2" />
		<param name="ymax" type="double" value="2" />
	</node>
</launch>
\end{lstlisting}
\hypersetup{urlcolor=black}
Fuente: \href{https://github.com/allenh1/p2os/blob/indigo-stable/p2os_launch/launch/gmapping.launch}{\textit{p2os/p2os\_launch/launch/gmapping.launch}}
\hypersetup{urlcolor=blue}
\caption{Launchfile slam\_gmaping}
\end{code}

Para visualizar la creación del mapa en RViz se ha creado un archivo específico:

\begin{code}[!htp]
\begin{lstlisting}[style=consola]
$ roslaunch pioneer_utils rviz-gmapping.launch
\end{lstlisting}
\hypersetup{urlcolor=black}
Fuente: \href{https://github.com/danimtb/pioneer3at_ETSIDI/blob/master/pioneer_utils/rviz/rviz-gmapping.launch}{\textit{pioneer\_utils/rviz/rviz-gmapping.launch}}
\hypersetup{urlcolor=blue}
\caption{Launchfile para visualizar slam\_gmaping en RViz}
\end{code}

\begin{figure}[!htp]
\centering
\includegraphics[width=0.8\textwidth]{figuras/pantalla_rviz_gmapping.png}
\caption{slam\_gmapping visualizado en RViz}
\label{fig:slam_gmapping_rviz}
\end{figure}

Finalmente, para guardar los mapas generados nos servimos de la herramienta map\_server que nos ofrece guardar mapas que se estén publicando en el topic \textit{map} así como publicar estos mapas para utilizarlos en la navegación.

\begin{code}[!htp]
\begin{lstlisting}[style=consola]
$ rosrun map_server map_saver
\end{lstlisting}
\caption{Ejecución del nodo map\_saver para guardar el mapa}
\end{code}

\section{AMCL}\label{section:amcl}
''Adaptative Monte Carlo Localizaion", también conocida por localización mediante filtro de partículas, es un algoritmo utilizado en robótica para determinar la posición de un robot en un mapa \cite{fox1999monte}.

El algoritmo emplea un filtro de partículas para representar una distribución de posibles estados dentro del mapa. A medida que los sensores detectan el entorno y el robot se desplaza dentro de este se van otorgando mayor peso a aquellas partículas que se encuentran más cercanas a la positicón correcta y se van descartando otras.

La idea de esta técnica es conseguir que toas las partículas converjan en una sola (a efectos prácticos, unas pocas partículas) para determinar la posición del robot en el mapa.

Esta técnica se encuentra en ROS bajo un paquete llamado \textit{amcl} \cite{amcl-ros} y utiliza las técnicas descritas en el libro Probabilistic Robotics \cite{thrun2005probabilistic}.

Transladado a la filosofía de funcionamiento de ROS, esta técnica nos ofrece la posibilidad de situar al robot en un mapa pregrabado, aportándonos la transformada entre el sistema de referencia (\textit{frame}) del mapa y el sistema de la odometría (Figura \ref{fig:amcl-ros}).

\begin{figure}[!htp]
\centering
\includegraphics[width=0.9\textwidth]{figuras/amcl-ros.png}
\caption{Esquema de la labor del nodo AMCL entre los \textit{frames} map y base.}
\label{fig:amcl-ros}
\end{figure}

\textbf{Configuración}

Como es habitual en ROS, esta funcionalidad nos aparece empaquetada en forma de nodo configurable a través de parámetros.

Para funcionar requiere el uso de un mapa, el árbol de transformadas de nuestro robot e información de tipo \textit{sensor\_msgs/LaserScan}.

La lista de parámetros configurables es amplia ya que debemos encontrar un modelo que se comporte bien con nuestro robot y sensor láser. Son especialmente importantes los parámetros del modelo de la odometría y los referentes al haz láser de nuestro sensor.

\begin{code}[!htp]
\begin{lstlisting}[style=launch]
<launch>
	<node pkg="amcl" type="amcl" name="amcl">
		<param name="odom_model_type" value="diff"/>
		<param name="odom_alpha5" value="0.1"/>
		<param name="transform_tolerance" value="0.2" />
		<param name="gui_publish_rate" value="10.0"/>
		<param name="laser_max_beams" value="30"/>
		<param name="min_particles" value="500"/>
		<param name="max_particles" value="5000"/>
		<param name="kld_err" value="0.05"/>
		<param name="kld_z" value="0.99"/>
		<param name="odom_alpha1" value="0.2"/>
		<param name="odom_alpha2" value="0.2"/>
		<param name="odom_alpha3" value="0.8"/>
		<param name="odom_alpha4" value="0.2"/>
		<param name="laser_z_hit" value="0.5"/>
		<param name="laser_z_short" value="0.05"/>
		<param name="laser_z_max" value="0.05"/>
		<param name="laser_z_rand" value="0.5"/>
		<param name="laser_sigma_hit" value="0.2"/>
		<param name="laser_lambda_short" value="0.1"/>
		<param name="laser_lambda_short" value="0.1"/>
		<param name="laser_model_type" value="likelihood_field"/>
		<param name="laser_likelihood_max_dist" value="2.0"/>
		<param name="update_min_d" value="0.2"/>
		<param name="update_min_a" value="0.5"/>
		<param name="odom_frame_id" value="odom"/>
		<param name="resample_interval" value="1"/>
		<param name="transform_tolerance" value="0.1"/>
		<param name="recovery_alpha_slow" value="0.0"/>
		<param name="recovery_alpha_fast" value="0.0"/>
	</node>
</launch>
\end{lstlisting}
\hypersetup{urlcolor=black}
Fuente: \href{https://github.com/danimtb/pioneer3at_ETSIDI/blob/master/pioneer_utils/navigation/common/amcl.launch}{\textit{pioneer\_utils/navigation/common/amcl.launch}}
\hypersetup{urlcolor=blue}
\caption{Launchfile del nodo amcl utilizado.}
\end{code}

\section{Mapas de coste: Costmaps}
Como ya se ha referido con anterioridad, el modelo de navegación que sigue el Navigation Stack de ROS se basa en el concepto de Costmaps.

Un costmap es un mapa  generado a partir de los obstáculos detectados por sensores que son representados en forma de mapa de celdas y sobre los que se calcula un gradiente de "coste" desde los obstáculos hasta las zonas despejadas. Este tipo de mapas pretenden disponer de la información necesaria para que el robot pueda navegar.

Generalmente, este enfoque solo tiene en cuenta navegación en un solo plano o navegación en dos dimensiones, ya que todos los objetos son incorporados al mapa sin importar su altura. Existe una variante que pseudo-3D que tiene en cuenta la altura a la que se sitúan los sensores, aunque no es el modelo típico de aplicación.

El funcionamiento de este tipo de mapas se basa en la incorporación o el borrado de obstáculos al mapa. Cada sensor puede utilizarse de manera independiente para incorporar o borrar obstáculos en estos mapas. Esto permite a nuestro sistema robótico abstraerse de la información directa de los sensores y obtener información más completa de todos los obstáculos su alrededor.

La principal ventaja de utilizar este tipo de mapas en navegación es la de crear mapas dinámicos locales en el que guardar información de los obstáculos alrededor del robot sin que necesariamente dispongamos de un sensor captando el mismo continuamente. Esto nos permite, por ejemplo, realizar navegación con un sensor con un rango horizontal de pocos grados, como el sensor Kinect, y aún así permitir al robot conocer información de obstáculos que han quedado fuera del rango del sensor.

El nodo encargado de la creación de estos costmaps es \textit{costmap\_2d} y su funcionamiento está basado en diferentes capas que manejan la infomración de los sensores y generan cálculos a partir de los mismos.

Las denominadas capas de las que hace uso \textit{costmap\_2d} son las siguientes:

\begin{itemize}
\item Satic Map: Esta capa es la encargada de tener el cuenta los obstáculos que aporta un mapa pregrabado en caso de utilizarse en la navegación. Está ligado al parámetro \textit{static\_map} y normalmente se utiliza con nodos de localización en un mapa como \textit{amcl}.

\item Obstacle Map: Esta capa es la encargada de incorporar o borrar obstáculos obteniendo la información de los sensores declarados en su archivo de configuración. Destaca la facilidad para incorporar varios sensores a la vez.

\item Inflation: En esta capa se realizan los cálculos de coste de cada celda a partir de la información que aportan las capas anteriores. Este gradiente de valores clasifica cada celda del mapa en diferentes tipos:

\begin{enumerate}[1.]
\item Letal: Existe un obstáculo real en esa celda del mapa
\item Inscrito: Las celdas con este valor se encuentran a una distancia de un obstáculo que es menor o igual al radio de la circunferencia inscrita en el área que ocupa el robot.
\item Posiblemente circunscrito: Celdas que se encuentran a una distancia de un obstáculo que es mayor que el radio de la circunferencia inscrita en el área que ocupa el robot pero menor que el radio de la circunferencia circunscrita. Esta información como "posible" debido que la orientación del robot puede no ser exacta.
\item Espacio libre: El coste de este tipo de celdas es cero e indica que no existe ningun obstáculo cercano que impida o limite el movimiento del robot.
\item Desconocido: No existe información sobre el estado de esa celda.

\end{enumerate}

\begin{figure}[!htp]
\centering
\includegraphics[width=\textwidth]{figuras/inflation_layer.png}
\caption{Esquema sobre el cálculo del coste de cada celda en el mapa.}
\label{fig:inflation_layer}
\end{figure}

Esta capa indica a los planificadores las zonas optimas por las que trazar su ruta, es la más importante y donde reside gran parte de la funcionalidad de los costmaps. Existen parámetros configurables por el usuario como el radio de inflado (\textit{inflation\_radius}) o el valor de escala (\textit{cost\_scaling\_factor}).
\end{itemize}

A parte de estas capas, existe una API que nos permite crear nuestras propias capas para el nodo \textit{costmap\_2d} para darles la funcionalidad que se desee.

Existe una configuración por defecto que de estos costmaps que genera una sola capa de obstáculos, una capa de inflado y adcionalmente una capa de mapa estático siempre y cuando pongamos el parámetro \textit{static\_map} a TRUE. Sin embargo, existe la posibilidad de crear costmaps con las capas que consideremos oportunas, siendo de especial interés poder incorporar diferentes capas de obstáculos.

Este último enfoque es el que ha sido adoptado en la implementación final de navegación y será descrito en el apartado **APARTADO**.

\section{Planificador de trayectoria global}\label{section:global_planner}
La planificación de trayectoria es una de las áreas que más interés suscita entre los investigadores relacionados con la robótica móvil o la navegación autónoma, no en vano, existe una gran variedad de algoritmos que realizan cálculos apoyándose en distintos enfoques matemáticos.

Los planificadores de trayectoria tratan de construir la ruta que lleve al robot desde su posición a un punto en un mapa o en un entorno que pudiera ser desconocido. Esta planificación es calculada en un ámbito que denominamos ''global'' ya que se realiza en función al mapa global (\textit{global\_costmap} en nuestro caso) y no se consideran los detalles del entorno local al robot. Es, por tanto, una aproximación al camino final que el robot va a seguir.

Por tanto, los planificadores de trayectoria global deben basarse en información almacenada del entorno como un mapa estático y el cálculo se realiza mediante el análisis de sus características.

En la figura \ref{fig:metodos_planificacion_trayectorias} se muestra una clasificación de los principales métodos de planificación de trayectorias

\begin{figure}[!htp]
\centering
\includegraphics[width=\textwidth]{figuras/metodos_planificacion_trayectorias.png}
\caption{Clasificación de los diferentes métodos de planificación de trayectorias. Basado en \cite{pardeiro2015}.}
\label{fig:metodos_planificacion_trayectorias}
\end{figure}

Los algoritmos implementados en ROS se basan en métodos discretos mediante grafos, debido a que los mapas utilizados son mapas de celdillas que pueden transformarse en un grafo por medio de la propiedad de vecindad. A continuación se describen los planificadores de trayectoria disponibles en ROS, su fundamento teórico y su comportamiento en el cálculo de la trayectoria.

\subsection{Algoritmo de Dijkstra}
El algoritmo de Dijkstra es un algoritmo para la determinación del camino más corto dado un vértice origen al resto de vértices de un grafo con costes en cada arista. Este algoritmo debe su nombre a Edsger Dijkstra, quien lo describió por primera vez en el año 1959.

El algoritmo de Dijkstra funciona visitando vértices partiendo desde el punto incial. Examina repetidamente los vértices próximos que aún no han sido examinados expandiéndose desde el punto de partida hasta el punto de meta. De esta forma el algoritmo garantiza que se encuentre uno de los caminos más cortos (pueden existir varios caminos igual de cortos).

\begin{figure}[!htp]
\centering
\includegraphics[width=\textwidth]{figuras/pseudo-dijkstra.png}
\caption{Pseudo-código del algoritmo de Dijkstra. Basado en \cite{tomovicpath}.}
\label{fig:pseudo_dijkstra}
\end{figure}

En la figura \ref{fig:algoritmo_dijkstra_libre} se pueden observar la implementación del algoritmo de Dijkstra. El punto de color rosa es el punto incial y el azúl oscuro el punto de meta.

\begin{figure}[!htp]
\centering
\includegraphics[width=0.6\textwidth]{figuras/algoritmo_dijkstra_libre.png}
\caption{Implementación del algoritmo de Dijkstra en un mapa sin obstáculos. Basado en \cite{AmitPathfinding}.}
\label{fig:algoritmo_dijkstra_libre}
\end{figure}

Comparándolo con el algoritmo heurístico "Greedy Best-First-Search algorithm", cuyo funcionamiento es similiar al algoritmo de Dijkstra aunque explora primero qué vertices se encuentran en dirección al punto de meta, vemos en la figura que el camino encontrado es similiar y que el número de vértices analizados se reduce considerablemente.

\begin{figure}[!htp]
\centering
\includegraphics[width=0.6\textwidth]{figuras/algoritmo_best-first-search_libre.png}
\caption{Implementación del algoritmo Best-First-Search en un mapa sin obstáculos. Basado en \cite{AmitPathfinding}.}
\label{fig:algoritmo_best-first-search_libre}
\end{figure}

Sin embargo, estamos analizando el mejor de los casos, cuando el mapa se encuentra libre de obstáculos. Situando un obstáculo cóncavo delante del punto inicial obtenemos el resultado de la figura \ref{fig:algoritmo_dijkstra_best-first-search}.

\begin{figure}[!htp]
\centering
\includegraphics[width=0.45\textwidth]{figuras/algoritmo_dijkstra.png}
\includegraphics[width=0.45\textwidth]{figuras/algoritmo_best-first-search.png}
\caption{Algoritmo de Dijkstra (Izq.) y algoritmo Best-First-Search (Dcha.) en un mapa con obstáculo cóncavo. Basado en \cite{AmitPathfinding}.}
\label{fig:algoritmo_dijkstra_best-first-search}
\end{figure}

El algoritmo Best-First-Search realiza un análisis de vértices menor hasta llegar al punto de meta comparado con el algoritmo de Dijkstra, lo cual se significa un menor coste computacional, sin embargo el camino obtenido no es el menor, ya que Best-First-Search prioriza aquellos vértices que se encuentran más cerca del punto de meta.

El algoritmo de Dijkstra garantiza que se encuentre el camino más corto entre los dos puntos a costa de realizar un análisis de vértices mayor. Como vemos, este algoritmo es más inmersivo expandiéndose por todos los vértices, sin embargo su resultado es el óptimo.

\subsection{Algoritmo de A estrella}
El algoritmo A estrella (denominado comúnmente A*) es un algoritmo para la búsqueda del camino más corto entre vértices origen y objetivo dentro de un grafo con costes en cada arista. Fue presentado por primera vez en 1968 por Peter E. Hart, Nils J. Nilsson y Bertram Raphael.

\begin{figure}[!htp]
\centering
\includegraphics[width=\textwidth]{figuras/pseudo-astar.png}
\caption{Pseudo-código del algoritmo A*. Basado en \cite{tomovicpath}.}
\label{fig:pseudo_dijkstra}
\end{figure}


El algoritmo A* combina el enfoque de algoritmos como Best-First-Search y Dijsktra. Este algoritmo favorece la creación de un camino por vértices que se encuentren cerca del punto incial, así como vértices que se encuentren en dirección al punto de meta. El cálculo del camino se basa en considerar tanto el coste de llegada hasta un nodo como en la estimación de la distancia que falta para alcanzarlo. SI la estimación es menor que el coste real, el resultado es óptimo.

\begin{figure}[!htp]
\centering
\includegraphics[width=0.45\textwidth]{figuras/algoritmo_a-estrella_libre.png}
\includegraphics[width=0.45\textwidth]{figuras/algoritmo_a-estrella.png}
\caption{Algoritmo A* sin obstáculo (Izq.) y con obstáculo cóncavo (Dcha.). Basado en \cite{AmitPathfinding}.}
\label{fig:algoritmo_a-estrella}
\end{figure}

En la figura \ref{fig:algoritmo_a-estrella} podemos observar el comportamiento del algoritmo en un mapa despejado y en otro con un obstáculo cóncavo. Los vértices en color amarillo muestran la transición partiendo desde el vértice incial y los de color azulado muestran la transición desde el vértice final.

El algoritmo A estrella ofrece por tanto unos resultados similares al algoritmo de Dijsktra en cuanto al camino calculado. Sin embargo análisis de los vértices es similar e incluso menor Best-First-Search y por tanto menor que en el de Dijsktra.


\section{Planificador de trayectoria local}
EL planificador de trayctoria local es el encargado de guiar al robot, según sus posibilidades de movimiento, hacia la ruta marcada por el planificador global. Este planificador de trayectoria se basa en el mapa de coste local, el cuál determina por la información de los sensores los obstáculos más próximos al robot.

La filosofía del planificador de trayectoria local es servir de control reactivo del robot además de conducirlo hacia la ruta marcada por el planificador global. Su misión es resolver las obstrucciones sobre la ruta global en el entorno local al robot para determinar la ruta real que será seguida. El modelo del entorno local se construye mediante la fusión de la información proporcionada por los sensores externos del robot móvil.

EL planificador de trayectoria local ya implementado en ROS utiliza los algoritmos \textit{Trajectory Rollout} y \textit{Dynamic Window} para realizar la navegación reactiva basada en un solo plano. Los pasos que realizan estos algoritmos son los siguientes:

\begin{figure}[!htp]
\centering
\includegraphics[width=0.45\textwidth]{figuras/local_plan.png}
\caption{Funcionamiento de los planificadores de trayectoria local.}
\label{fig:local_plan}
\end{figure}

\begin{enumerate}
\item Muestreo discreto del espacio de control del robot según sus velocidades en cada eje.
\item Para cada velocidad, realizar una simulación desde el estado actual del robot para predecir la posición del robot durante un periodo corto de tiempo.
\item Evaluar cada unoa de las trayectorias resultantes del paso anterior utilizando características como la proximidad a los obstáculos, proximidad a la meta, proximidad a la ruta global y la velocidad.
\item Repetir los pasos anteriores hasta alcanzar el punto final de meta.
\end{enumerate}

La diferencia entre los algoritmos \textit{Trajectory Rollout} \cite{gerkey2008planningy} \textit{Dynamic Window} \cite{fox1997dynamic} es el modo en el que se realiza el muestreo del espacio de control del robot. \textit{Trajectory Rollout} muestrea todas las trayectorias alcanzables variando la velocidad en todo el periodo de simulación, mientras que \textit{Dynamic Window} realiza la evaluación de las trayectorias en cada uno de los pasos, evaluando la velocidad  comparándola con las capacidades de aceleración del robot.

\textit{Dynamic Window} es un algoritmo más eficiente pero que se comporta peor en robots con bajos límites de aceleración por lo que en ocasiones el algoritmo \textit{Trajectory Rollout} realiza trayectorias locales más adecuadas.