\chapter{Pruebas del sistema}
En este capítulo se describen las principales pruebas realizadas con el robot de tal modo que sirva para validar el trabajo realizado y exponer a los resultados obtenidos.

Dividimos este capítulo en dos partes, pruebas del robot en simulación y pruebas en el entorno real, centrándonos exclusivamente en la creación de mapas mediante SLAM y los tests de navegación.

\section{Simulación con MobileSim}\label{MobileSim}
Una de las ventajas de utilizar el nodo rosaria para controlar el robot y obtener los datos de odometría es que las herramientas ofrecidas por el fabricante siguen pudiendo utilizarse. Este es el caso del simulador MobileSim.

MobileSim es un simulador robótico en dos dimensiones creado para los robots de Adpet Mobile Robots que puede utilizarse con robots controlados mediante la librería Aria.

Su funcionamiento es el siguiente: El simulador abre un puerto de comunicación local en el ordenador y al ejecutar la conexión con el robot de Aria, si el robot no se encuentra se procede a conectarse a dicho puerto de comunicación. Esto nos permite utilizar MobileSim con RosAria de la misma manera y sin cambiar nuestra configuración.

\begin{figure}[htp]
\centering
\includegraphics[width=0.7\textwidth]{figuras/mobilesim.png}
\caption{MobileSim junto con RViz funcionando con teleoperación.}
\label{fig:mobilesim}
\end{figure}

Las pruebas con este simulador sirvieron para comprobar que el nodo rosaria disponía de la funcionalidad adecuada, así como para realizar pruebas con el nodo de teleoperación y dead reckoning (Figura \ref{fig:mobilesim}).

Por otro lado, las limitaciones de este simulador son evidentes. No existe posibilidad de simular otros sensores incorporados al robot, la integración de ROS se realiza con una librería intermedia y la más importante, no puede simularse un entorno en tres dimensiones.

\section{Simulación con Gazebo}\label{Gazebo}
El simulador Gazebo permite realizar configuraciones más elaboradas y su integración con ROS es completa a pesar de que existen ciertas dificultades en su configuración.

En este entorno podemos simular el robot Pioneer 3 AT y dotarle de los sensores necesarios mediante plug-ins desarrollados que simulan los diferentes sensores y actuadores.

\subsection{Modelado del robot en el simulador}

Gazebo es capaz de simular robots definidos mediante archivos URDF, donde se indica cada tipo articulación y eslabón del robot. Además existen archivos de propiedades de los materiales y características específicas de gazebo que se definen a parte.

A continuación se hace un breve descripción de los archivos utilizados y su función\footnote{\hypersetup{urlcolor=black}
La configuración de Gazebo puede encontrarse en: \href{https://github.com/danimtb/pioneer3at_ETSIDI/tree/master/pioneer_utils/gazebo}{\textit{pioneer\_utils/gazebo}}
\hypersetup{urlcolor=blue}}:

\begin{itemize}
\item \textbf{pioneer3at.xacro:} Es el archivo principal donde se define el modelo del robot mediante URDF y se llama a los plug-ins de los sensores y actuadores y los demás archivos xacro.

\item \textbf{materials.xacro:} Se definen propiedades de los materiales de cada parte del robot.

\item \textbf{pioneer3at\_wheels.xacro:} Macro para definir las ruedas del robot.

\item \textbf{pioneer3at\_pilars.xacro:} Macro para definir las barras de sujeción del robot.

\item \textbf{pioneer3at.gazebo:} Define funcionalidades adicionales de gazebo. Aquí se definen los plug-ins a utilizar como \textit{skid\_steer\_drive\_controller} para el movimiento del robot o \textit{kinect\_camera\_controller} para simular el sensor Kinect.

\item \textbf{pioneer3at.world:} Es un archivo específico del simulador que guarda una descripción del mundo virtual. En este caso se trata de un mundo sin objetos.

\item \textbf{pioneer3at\_gazebo\_world.launch:} Archivo principal para lanzar el simulador. En él se lanza el mundo virtual (configurado para utilizar \textit{willowgarage\_world}), el modelo del robot creado y el nodo \textit{robot\_state\_publisher} que realiza la publicación de transformadas entre los diferentes ejes de coordenadas en base al modelo de nuestro robot.
\end{itemize}

La definición URDF es la más importante ya que configura los parámetros del robot como el peso de cada parte, el material, el momento de inercia...

A continuación se muestra un fragmento de \textit{pioneer3at.xacro} donde se describe el elemento qu conforma la parte superior del robot y su ``articulación estática" (fixed) con el chasis:

\begin{code}[!htp]
\begin{lstlisting}[style=launch]

	<!-- Top -->
	<link name="top_plate">
		<inertial>
			<mass value="0.1"/>	
			<origin xyz="-0.025 0 -0.223"/>
			<inertia ixx="1.0" ixy="0.0" ixz="0.0"
				 iyy="1.0" iyz="0.0"
 				izz="1.0"/>
		</inertial>
		<visual name="top_visual">
			<origin xyz="0 0 0" rpy="0 0 0"/>
			<geometry name="pioneer_geom">
				<mesh filename="package://p2os_urdf/meshes/p3at_meshes/top.stl"/>
			</geometry>
			<material name="TopBlack">
					<color rgba="0.038 0.038 0.038 1.0"/>
			</material>
		</visual>
		<collision>
			<origin xyz="0 0 0" rpy="0 0 0"/>
			<geometry>
				<box size="0 0 0"/>
			</geometry>
		</collision>
	</link>

	<joint name="base_top_joint" type="fixed">
		<origin xyz="0.003 0 0.274" rpy="0 0 0"/>
		<parent link="base_link"/>
		<child link="top_plate"/>
	</joint>
\end{lstlisting}
\caption{Fragmento de la configuración URDF del robot.}\footnotemark
\end{code}
\footnotetext{\hypersetup{urlcolor=black}
Fuente: \href{https://github.com/danimtb/pioneer3at_ETSIDI/blob/master/pioneer_utils/gazebo/pioneer3at.xacro}{\textit{pioneer\_utils/gazebo/pioneer3at.xacro}}
\hypersetup{urlcolor=blue}}

La parte gráfica recae en los elementos "mesh"\footnote{\hypersetup{urlcolor=black}
Los diseños 3D se encuentran en: \href{https://github.com/danimtb/pioneer3at_ETSIDI/tree/master/pioneer_utils/gazebo/meshes}{\textit{pioneer\_utils/gazebo/meshes}}
\hypersetup{urlcolor=blue}}: Objetos definidos por mallas en formato \textit{.stl} generados con un programa de modelado en tres dimensiones. Con las dimensiones de esos archivos también podemos simplificar el modelado de colisión para cada pieza.

Este archivo con la definición del robot se carga junto con el mundo virtual y nodos auxiliares para simular el robot e iniciar Gazebo. Esto se recoge en el archivo \textit{pioneer3at\_gazebo\_world.launch:}
mostrado a continuación.

\begin{code}[!htp]
\begin{lstlisting}[style=launch]
<launch>

  <!-- these are the arguments you can pass this launch file, for example paused:=true -->
  <arg name="paused" default="false"/>
  <arg name="use_sim_time" default="true"/>
  <arg name="gui" default="true"/>
  <arg name="headless" default="false"/>
  <arg name="debug" default="false"/>

  <!-- We resume the logic in empty_world.launch, changing only the name of the world to be launched -->
  <include file="$(find gazebo_ros)/launch/willowgarage_world.launch">
  </include>

  <!-- Load the URDF into the ROS Parameter Server -->
  <param name="robot_description"
	 command="$(find xacro)/xacro.py $(find pioneer_utils)/gazebo/pioneer3at.xacro" />

  <!-- Run a python script to the send a service call to gazebo_ros to spawn a URDF robot -->
  <node name="urdf_spawner" pkg="gazebo_ros" type="spawn_model" respawn="false" output="screen"
	args="-urdf -model pioneer3at -param robot_description"/>

  <!-- publish all the frames to TF -->
  <node name="robot_state_publisher" pkg="robot_state_publisher" type="state_publisher">
    <param name="publish_frequency" value="50"/> <!-- Hz -->
  </node>

  <!-- Launch kinect and depthimage_to_laser node -->
  <include file="$(find pioneer_utils)/sensors/kinect_to_laser_low.launch"/>

  <!-- Launch kinect and depthimage_to_laser node -->
  <include file="$(find pioneer_utils)/sensors/kinect_to_laser_long.launch"/>

  <!-- Launch kinect and depthimage_to_laser node -->
  <include file="$(find pioneer_utils)/sensors/kinect_to_laser.launch"/>

</launch>
\end{lstlisting}
\caption{Launchfile para lanzar Gazebo con el modelo del robot y sus sensores.}\footnotemark
\end{code}
\footnotetext{\hypersetup{urlcolor=black}
Fuente: \href{https://github.com/danimtb/pioneer3at_ETSIDI/blob/master/pioneer_utils/gazebo/pioneer3at_gazebo_world.launch}{\textit{pioneer\_utils/gazebo/pioneer3at\_gazebo\_world.launch}}
\hypersetup{urlcolor=blue}}

Las pruebas con Gazebo fueron realizadas gracias a la correcta configuración de todos estos archivos para los cuales no existía una documentación unificada debido al cambio de versiones tanto de Gazebo como de ROS. Se tomaron como punto de partida las siguientes referencias **REFERENCIAS**.

\begin{figure}[!htp]
\centering
\includegraphics[width=0.7\textwidth]{figuras/gazebo_simulado.png}
\caption{Simulación en Gazebo y visualizado de datos en RViz.}
\label{fig:gazebo_simulado}
\end{figure}

\begin{figure}[!htp]
\centering
\includegraphics[width=0.8\textwidth]{figuras/gazebo_willowgarage.png}
\caption{Pioneer 3 AT simulado en el mapa Willow Garage.}
\label{fig:gazebo_willowgarage}
\end{figure}

\pagebreak

\subsection{Pruebas simuladas}
La ventaja de disponer del simulador Gazebo funcionando con el modelo de nuestro robot permitió que el robot evolucionase más rápido debido a que los cambios se probaban de manera inmediata y que puedieran probarse otras configuraciones del robot, validarlas y finalmente implementarlo en el robot real.

Con la ayuda de Gazebo se han podido probar todas las configuraciones de navegación, el funcionamiento de cada nodo y el intercambio de datos entre ellos.

\subsubsection{SLAM}
Las pruebas de SLAM se realizaron con el ya mencionado paquete \textit{gmapping}, funcionando de la manera habitual.

Para comprobar su validez, se utilizó dispuso al robot en el mundo "Willow Garage" que simula un entorno de oficinas, similar al entorno real del laboratorio. El objetivo principal fue comprobar que el algoritmo de mapeado funcionaba correctamente y si se conseguía cerrar el mapa realizando un bucle completo.

Para esta prueba se utilizó el nodo de mapeado y el de teleoperación y se guió al robot por una parte del entorno realizando diversos bucles (Figura \ref{fig:slam_gazebo}), en los que se observa que no existe distorsión en paredes paralelas y que el mapa no se encuentra solapado.

\begin{figure}[!htp]
\centering
\includegraphics[width=0.8\textwidth]{figuras/slam_gazebo.png}
\caption{Prueba de SLAM en el simulador Gazebo.}
\label{fig:slam_gazebo}
\end{figure}

Indicar que este fue el mapa base utilizado para la navegación de sucesivas pruebas con Gazebo en las cuales el nodo AMCL situó correctamente al robot en el entorno virtual, por lo que validación del mapa generado es correcta.

\subsubsection{Navegación con mapa}
Las navegaciones con mapa en el simulador fueron determinantes para realizar una configuración más elaborada de ambos costmaps debido a los problemas con el borrado de los obstáculos (ver Subsección \label{subsection:configuracion_costmaps_sensores}).

En un principio se valoró la posibilidad de utilizar el sensor Kinect tan solo para obstáculos locales y el sensor láser para obstáculos globales, sin embargó se descartó ya que el robot trataba de seguir una trayectoria global incorrecta que no contemplaba los obstáculos bajos (Figura), con las complicaciones de control que eso supone para el planificador de trayectoria local.

\begin{figure}[!htp]
\centering
\includegraphics[width=0.65\textwidth]{figuras/discrepancia_costmaps_gazebo.png}
\caption{Trayectoria global erronea.}
\label{fig:discrepancia_costmaps_gazebo}
\end{figure}

Esto determinó, junto con las características especiales del sensor Kinect, que los sensores fueran recolocados para la configuración final del robot y que se añadiesen capas de obstáculos diferenciadas para cada sensor.

Pruebas posteriores con la nueva configuración y obstáculos bajos determinaron la configuración correcta. Además se configuró un cálculo de trayectoria global repetitivo, de tal modo que el planificador global genera trayectorias actualizadas a medida que el robot incorpora los obstáculos al mapa. Esto ayuda al planificador local de trayectoria y en definitiva a que el robot realice menos maniobras.

\begin{figure}[!htp]
\centering
\includegraphics[width=0.7\textwidth]{figuras/navegacion_global_gazebo.png}
\caption{Navegación con mapa final.}
\label{fig:navegacion_global_gazebo}
\end{figure}

\subsubsection{Navegación reactiva}
La nagación reactiva es una configuración menor de la anterior, por lo que no supuso un desarrollo más elaborado en las pruebas realizadas.

Consistieron en realizar navegación mandando al robot hacia varios puntos de meta y comprobar si se quedaba atascado en algún momento.

Las pruebas determinaron que el robot mostraba el mismo comportamiento en la navegación pero existían limitaciones como la distancia a la que pueden encontrarse los puntos de meta (puntos más cercanos al robot debido a la ausencia de mapa) o solapamientos y giros en el mapa global si este era demasiado grande.

Como es normal en una navegación reactiva, el robot se desplaza siguiendo la trayectoria más corta en base a la información que sus sensores captan en ese momento, por lo que suceden casos como en la figura *TAL*. A pesar de ello, gracias a la información de los obstáculos que queda retenida en el mapa global, el planificador recalcula.

\begin{figure}[!htp]
\centering
\includegraphics[width=0.40\textwidth]{figuras/navegacion_local1_gazebop.png}
\includegraphics[width=0.40\textwidth]{figuras/navegacion_local2_gazebop.png}
\caption{Navegación con mapa final.}
\label{fig:navegacion_local_gazebo}
\end{figure}
\subsubsection{Pruebas de resistencia}
Para las pruebas de resistencia utilizamos un nodo desarrollado en Python específicamente creado para el caso.

En estas pruebas se consideraron los siguientes aspectos:
\begin{itemize}
\item Puntos de meta: Puntos totales repartidos por el mapa que serviran como puntos objetivo a alcanzar por el robot.
\item Tiempo total: Tiempo total de la prueba.
\item Metas enviadas: Número total de puntos de meta que se han enviado como objetivo al robot durante la prueba.
\item Metas alcanzadas: Número de metas a las que ha conseguido llegar el robot.
\item Tasa de metas alcanzadas: Tanto por ciento de las metas alcanzadas respecto de las enviadas.
\item Distancia total: Distancia total recorrida, considerando obstáculos intermedios y maniobras o replanificación de trayectorias del robot.
\item Nº de choques: Número de obstáculos con los que el robot ha chocado (si los hubiera).
\end{itemize}

Las pruebas de resistencia se realizaron en el modo de navegación con mapa, el entorno virtual fue el mundo "Willow Garage" y se utilizaron un total de 9 puntos de meta como objetivo, distribuidos de manera aleatoria (dentro de habitaciones, pasillos, salas grandes...) a distancias largas. Cabe señalar que no existe ningún tipo de obstáculo móvil implicado en estas pruebas.

\textbf{Primera prueba}\\
Prueba inicial sin obstáculos adicionales en el entorno.

\begin{table}[!h]
\centering
\resizebox{0.5\textwidth}{!}{
\begin{tabular}{c c}
\hline
Puntos de meta &  9 \\
Tiempo total & 20 minutos \\
Metas enviadas & 18 \\
Metas alcanzadas & 18 \\
Tasa metas alcanzadas & 100\% \\
Distancia total & 275.2 metros \\
Nº de choques & 0 \\
\hline
\end{tabular}
}
\caption{Primera prueba de resistencia simulada.}
\label{tabla:primera_prueba_simulada}
\end{table}
La navegación del robot fue correcta durante toda la prueba.

\pagebreak

\textbf{Segunda prueba}\\
Segunda prueba más larga y con obstáculos adicionales en el entorno.

\begin{table}[!h]
\centering
\resizebox{0.5\textwidth}{!}{
\begin{tabular}{c c}
\hline
Puntos de meta &  9 \\
Tiempo total & 56 minutos \\
Metas enviadas & 29 \\
Metas alcanzadas & 22 \\
Tasa metas alcanzadas & 75\% \\
Distancia total & 354.6 metros \\
Nº de choques & 0 \\
\hline
\end{tabular}
}
\caption{Segunda prueba de resistencia simulada.}
\label{tabla:segunda_prueba_simulada}
\end{table}
La prueba finalizó debido a que el robot quedó inmobilizado por encontrarse demasiado cerca de una pared frontal y otra lateral. El incremento de tiempo a pesar de no haber recorrido muchos más metros respecto de la prueba anterior se debe a las esperas por reintento en alcanzar las metas fallidas.

A pesar de todo el robot no colisiona con ningún obstáculo.

\textbf{Tercera prueba}\\
Tercera prueba con las mismas características que la anterior. El objetivo de esta prueba era recorrer una distancia total más larga sin colisión.

\begin{table}[!h]
\centering
\resizebox{0.5\textwidth}{!}{
\begin{tabular}{c c}
\hline
Puntos de meta &  9 \\
Tiempo total & 23 minutos \\
Metas enviadas & 18 \\
Metas alcanzadas & 15 \\
Tasa metas alcanzadas & 83\% \\
Distancia total & 488.8 metros \\
Nº de choques & 0 \\
\hline
\end{tabular}
}
\caption{Tercera prueba de resistencia simulada.}
\label{tabla:tercera_prueba_simulada}
\end{table}
Las metas no alcanzadas se produjeron por un exceso de tiempo en alcanzarlas, saltando el timeout y abortando la meta objetivo.

Esta prueba nos ofrece resultados de que los planificadores responden bien en el cálculo de trayectorias hacia puntos de meta alejados.

\section{Pruebas reales}
Las pruebas reales se llevaron a cabo en el robot con su configuración hardware y configuración del sistema final. Todos los nodos se ejecutan en el ordenador integrado Intel NUC y se utiliza un ordenador cliente para visualizar datos o teleoperar el robot en caso necesario.

Las pruebas de navegación con y sin mapa se han omitido debido a que los resultados fueron correctos y no se observaron grandes diferencias respecto a los resultados obtenidos en el simulador.

\subsection{SLAM}
\subsection{Prueba de resistencia}
Las pruebas de resistencia se llevaron a cabo en las instalaciones de la planta baja de la universidad.

Se han llevado a cabo mediante el nodo de resistencia creado para el caso y utilizando diversos puntos dentro del mapa "floor\_zero-map"\footnote{\hypersetup{urlcolor=black}Fuente: \href{https://github.com/danimtb/pioneer3at_ETSIDI/blob/master/pioneer_utils/maps/floor_zero-map.pgm}{\textit{pioneer\_utils/maps/floor\_zero-map.pgm}}
\hypersetup{urlcolor=blue}} que abarca las zonas indicadas.

El objetivo primordial de las pruebas es que el robot sea capaz de navegar sin ningún tipo de intervención humana, ya que invalidaría el concepto de robot autónomo.

\textbf{Primera prueba}\\
Primera prueba real desarrollada en el laboratorio con obstáculos y personas en movimiento.

\begin{table}[!h]
\centering
\resizebox{0.5\textwidth}{!}{
\begin{tabular}{c c}
\hline
Puntos de meta &  7 \\
Tiempo total & 44 minutos \\
Metas enviadas & 91 \\
Metas alcanzadas & 56 \\
Tasa metas alcanzadas & 61\% \\
Distancia total & - \\
Nº de choques & 0 \\
\hline
\end{tabular}
}
\caption{Primera prueba de resistencia real\protect\footnotemark.}
\label{tabla:primera_prueba_real}
\end{table}
\footnotetext{La distancia total recorrida no pudo contabilizarse debido a un error en la configuración del nodo.}

Los resultados de la primera prueba no reflejan una navegación buena del robot, sin embargo esto es debido a la existencia de obstáculos prominentes no incluidos en el mapa del laboratorio que generaban distorsión en AMCL provocando que el robot quedase mal situado en el mapa. Estos obstáculos generaban a su vez un pasillo estrecho a través del cuál el planificador en ocasiones no era capaz de trazar una trayectoria correcta hasta la meta.

A pesar de ello el robot no colisionó con ningún tipo de obstáculo.

\textbf{Segunda prueba}\\
Segunda prueba de mayor recorrido, con obstáculos adicionales en el entorno y personas en movimiento. El objetivo de la prueba era medir la total movilidad del robot en el laboratorio.

\begin{table}[!h]
\centering
\resizebox{0.5\textwidth}{!}{
\begin{tabular}{c c}
\hline
Puntos de meta &  7 \\
Tiempo total & 57 minutos \\
Metas enviadas & 141 \\
Metas alcanzadas & 114 \\
Tasa metas alcanzadas & 80\% \\
Distancia total & 1119.5 metros \\
Nº de choques & 4 \\
\hline
\end{tabular}
}
\caption{Segunda prueba de resistencia real.}
\label{tabla:segunda_prueba_real}
\end{table}
La prueba finalizó por falta de batería en el robot, sin embargo no puede considerarse que ese tiempo sea la duración de la misma en navegación con el robot ya que no se encontraba al 100\% (aproximadamente la duración es de 2 horas y media).

Las metas no alcanzadas se produjeron por obstáculos móviles (personas en movimiento) bloqueando el paso del robot (imposible llegar a la meta físicamente). También se produjeron metas abordadas por riesgo de colisión (el robot había quedado situado muy cerca de las patas de una mesa).

Los choques fueron roces leves de las ruedas con obstáculos bajos. Esto es debido a que el planificador ajusta mucho la trayectoria para que el robot pueda navegar por lugares estrechos.

\subsection{Ascpectos de la navegación}

Tras las pruebas realizadas, analizando los resultados y observando el comportamiento general de todo el sistema robótico podemos decir que existen algunas limitaciones en la navegación y aspectos que no se tienen en cuenta por las características del robot.

\begin{itemize}
\item En cuanto a la navegación:\\
Existen limitaciones en cuanto a rampas, ya que este modo de navegación no tiene en cuenta la inclinación del robot para saber si este se encuentra desplazándose por un plano inclinado. Por otro lado tampoco es posible distinguir cambios por debajo del plano de navegación como agujeros, escalones... Estos dos aspectos se deben principalmente a que la navegación se realiza puramente en dos dimensiones.

No obstante, el sistema sí es capaz de absorber pequeñas rampas en las que los sensores no reciban excesivas interferencias con el cambio de plano y siempre que el robot no realice muchos giros para no comprometer la localización debido a una mala lectura de la odometría.
\end{itemize}
En cuanto a la navegación:
existen limitaciones en cuanto agujeros o rampas, ya que este modo de navegación no tiene en cuenta la inclinación del robot para saber si este se encuentra desplazándose por un plano inclinado.
