\chapter{Conceptos previos}
En este capítulo se exponen las particularidades de ROS y su funcionamiento así como la estructura del proyecto software desarrollado en este trabajo.

\section{Entorno ROS}

La versión del software ROS que se ha utilizado para el desarrollo del proyecto ha tratado de ser siempre la más actual posible, ya que eso nos asegura mantener la compatibilidad en futuros trabajos y que el software esté actualizado.

El sistema se ha desarrollado bajo la versión ROS Indigo Igloo ,en el sistema operativo Ubuntu 14.04. A fecha de entrega del proyecto existe una versión más actualizada de ROS, sin embargo se desestimó su uso debido a que aún no era una versión estable y algunos paquetes no se encontraban disponibles para dicha versión.

ROS realiza funciones similares a un sistema operativo, como la comunicación e interacción entre diferentes procesos, la distribución en hilos, comunicación distribuida entre máquinas, abstracción del hardware, control a bajo nivel, etc.

ROS también proporciona herramientas y librerías para crear código, compilarlo y ejecutarlo en diferentes máquinas.

El concepto más importante dentro de ROS es el nodo, que no son más que un proceso que se ejecuta y conecta al proceso principal, llamado MASTER, para comunicarse con otros nodos. Existen diferentes modos de interacción entre ellos: rostopics, rosservices, nodelets, etc. Los más usuales se explican con más detalle a continuación.

\subsection{Funcionamiento de ROS}

Como hemos dicho, en ROS las acciones del robot se llevan a cabo mediante la interacción de diferentes nodos que se conectan entre sí en forma de grafo. Cada nodo se conecta a un nodo principal llamado MASTER (roscore) que se encarga de abrir un canal de comunicación entre cada nodo o proceso.

En la figura \ref{fig:nodos_conectados} vemos un ejemplo para el robot simulado \textit{turtlesim}, al cual le envía comandos el nodo de teleoperación \textit{teleop\_turtle} y ambos publican información a través del nodo \textit{rosout}.

\pagebreak

\begin{figure}[htp]
\centering
\includegraphics[width=0.8\textwidth]{figuras/rosgraph.png}
\caption{Grafo de ejemplo con nodos conectados}
\label{fig:nodos_conectados}
\end{figure}

Teniendo esta estructura en mente, es conveniente definir algunos conceptos sobre los que trabaja ROS:

\begin{itemize}
\item Nodos (nodes): Los nodos son procesos que realizan algún tipo de cómputo. Un robot basado en ROS precisará de varios nodos ejecutándose al mismo tiempo e intercambiándose información a través de Topics, Servicios y Parámetros.

\item Máster (master): El nodo ROS master proporciona una vía comunicación para el intercambio de mensajes y un registro de cada nodo. También dispone de un registro de parámetros a los que pueden tener acceso cualquiera de los nodos.

\item Mensajes (messages): Los nodos se comunican unos con otros a través de mensajes. La estructura de estos mensajes puede definirse por el usuario y contener diferentes tipos de datos.

\item Topics: Los mensajes son transmitidos a través de un sistema de publicación / subscripción. Un nodo envía un mensaje publicándolo en cierto topic y otro nodo puede leer el mensaje si se suscribe.

\item Servicios (services): Los servicios son similares a los topics pero son mucho más apropiados para realizar comunicaciones del tipo solicitud / respuesta.

\item Bags: El concepto de "bag" puede entenderse como un almacén de mensajes. Los mensajes de cierto topic pueden guardarse para analizar los datos más tarde o reproducir cierta situación.
\end{itemize}

\begin{figure}[htp]
\centering
\includegraphics[width=0.8\textwidth]{figuras/esquema_ros.png}
\caption{Esquema del funcionamiento de ROS}
\label{fig:esquema_ros}
\end{figure}

A nivel de sistema de ficheros ROS se estructura de la siguiente forma:

\begin{itemize}
\item Paquetes (packages): Es la unidad principal de organización de software en ROS. Un paquete puede contener nodos, tipos de datos, archivos de configuración.

\item Metapaquetes (metapackages): Sirven para representar un conjunto de paquetes que tienen relación entre sí.

\item Package manifests: Son archivos de tipo xml donde se indican los metadatos de un paquete, como su nombre, su versión, una descripción, licencia, dependencias de otras librerías o paquetes...

\item Repositorios: Normalmente, para distribuir los paquetes en ROS se utilizan repositorios bajo un sistema de control de versiones.

\item Tipos de mensajes: Son archivos con la estructura de un
tipo de mensaje (MiMensaje.msg)

\item Tipos de servicios: Son archivos con la estructura de un tipo de servicio tanto para los datos de solicitud como los de respuesta (MiServicio.srv)
\end{itemize}

También es necesario conocer algunos tipos de archivos y su uso dentro de ROS para comprender el trabajo de este proyecto:

\begin{itemize}
\item Launchfiles: ROS ofrece la herramienta \textit{''roslaunch''} para ejecutar varios nodos con un solo comando y configurar sus parámetros. Es una forma cómoda de organizar la puesta en marcha de todos los nodos y enlazar unos \textit{launchfiles} con otros. Los archivos suelen tener la extensión \textit{.launch} y su estructura es similar a la sintaxis xml.

\item yaml: Es un formato de serialización de datos legible para los humanos de tal modo que se enfoca más en los datos que en el marcado de los archivos. Su formato es \textit{.yaml} y se utiliza para definir parámetros en cada nodo.

\item xacro: Son archivos que combinan el lenguaje xml con macros de tal modo que podemos mantener los archivos más legibles y ordenados. Estos archivos se utilizan principalmente para definir un modelo de nuestro robot en URDF (Unified Robot Description Format) y su extensión es \textit{.xacro}.

\item URDF (Unified Robot Description Format): Es un tipo de formato utilizado para describir la estructura de un objeto en forma de eslabones y articulaciones de distinto tipo \cite{urdf}. En ROS se utilizan para generar modelos del robot en Gazebo y en RViz y conocer de manera gráfica el estado de los eslabones del robot. La extensión de estos archivos es \textit{.urdf}.

\item gazebo: Los archivos \textit{.gazebo} definen características concretas para utilizar robots definidos mediante URDF. Estos archivos permiten desacoplar las características utilizadas en Gazebo del modelo original.

\item world: Los archivos \textit{.world} definen en sintaxis xml mundos virtuales para cargar en el simulador Gazebo. Pueden definirse los objetos a incorporar, las luces y la posición del punto de vista.
\end{itemize}

Por último, cabe destacar la importancia de uno de los paquetes integrados en ROS que más beneficios nos aporta, el paquete de transformadas \textit{tf}.

\textit{tf} \cite{tf} es uno de los paquetes de geometría dentro de ROS que nos permite realizar transformadas de los datos de un sistema de coordenadas concreto a otro. estos sistemas de coordenadas son denominados como \textit{frames} y realizan la transformación de los datos de manera periódica. Muchas funcionalidades de ROS se basan en este tipo de transformadas para realizar los cálculos matemáticos oportunos así como para determinar la posición de nuestro robot y sus articulaciones.

\begin{figure}[htp]
\centering
\includegraphics[width=0.6\textwidth]{figuras/frames.png}
\caption{Frames utilizados en el robot PR2.}
\label{fig:frames}
\end{figure}

\subsection{Configuración de ROS}
Para la instalación de ROS es necesario seguir ciertos pasos bien explicados en la wiki de su página\footnote{Instalación ROS: \url{http://wiki.ros.org/indigo/Installation/Ubuntu}}. Al ser un sistema fuertemente basado en sistemas UNIX y con mayor soporte para Ubuntu, las instalaciones se realizan principalmente a través de herramientas como apt (Advanced Packaging Tool).

Existen diferentes instalaciones de ROS dependiendo de si precisamos de todas sus herramientas y utilidades o no, ya que por ejemplo no tendría sentido instalar herramientas de interfaz gráfica en un robot que dispone de entorno gráfico. Para el ordenador de a bordo del robot utilizamos la versión completa del software.

\begin{code}[htp]
\begin{lstlisting}[style=consola]
$ sudo apt-get install ros-indigo-desktop-full
\end{lstlisting}
\caption{Mandato de consola para instalar la versión completa de ROS Indigo.}
\end{code}

Añadimos nuestra variable de entorno para que el sistema reconozca las herramientas de ROS:

\begin{code}[htp]
\begin{lstlisting}[style=consola]
$ source /opt/ros/indigo/setup.bash
\end{lstlisting}
\caption{Source al setup de ROS Indigo}
\end{code}

Para el desarrollo dentro de ROS se utiliza el entorno de desarrollo Catkin \ref{catkin}, que facilita el enlazado y compilación de los paquetes. Para ello es necesario instalarlo y crear un entorno de desarrollo:

\begin{code}[htp]
\begin{lstlisting}[style=consola]
$ sudo apt-get install ros-indigo-catkin
$ mkdir -p ~/catkin_ws/src
$ cd ~/catkin_ws/src
$ catkin_init_workspace
\end{lstlisting}
\caption{Instalación y workspace de Catkin}
\end{code}

Y a continuación es necesario incluir nuestro directorio de desarrollo para que sea reconocido:

\begin{code}[!htp]
\begin{lstlisting}[style=consola]
$ cd ~/catkin_ws
$ source devel/setup.bash
\end{lstlisting}
\caption{Source al setup de nuestro entorno Catkin}
\end{code}

A partir de este punto podríamos crear nuestros propios paquetes utilizando las funcionalidades de ROS \footnote{Crear un paquete Catkin \url{http://wiki.ros.org/catkin/Tutorials/CreatingPackage}}.

\subsection{Configuración de los paquetes ROS}

Los paquetes ROS son funcionalidades desarrolladas por terceros que se integran en el sistema ROS y que son transferibles de un robot a otro.

Los paquetes ROS incorporan un archivo \textit{CMakeLists.txt} para la compilación de los nodos que se hayan desarrollado así como sus mensajes y un archivo Package Manifest (\textit{package.xml}), como hemos indicado anteriormente.

Para el desarrollo de este proyecto es necesario clonar el repositorio GitHub \href{https://github.com/danimtb/pioneer3at_ETSIDI}{\textit{ pioneeer3at\_ETSIDI}} en nuestra carpeta \textit{$\sim$/catkin\_ws/src}. Este repositorio contiene todos los paquetes necesarios en nuestro entorno:

\begin{code}[!htp]
\begin{lstlisting}[style=consola]
$ cd ~/catkin_ws/src
$ $ git clone --recursive https://github.com/danimtb/pioneer3at_ETSIDI.git .
\end{lstlisting}
\caption{Clonado del repositorio \textit{pioneer3at\_ETSIDI}\footnotemark.}
\end{code}
\footnotetext{Fuente: \href{https://github.com/danimtb/pioneer3at_ETSIDI}{\textit{https://github.com/danimtb/pioneer3at\_ETSIDI}}}

Junto con el repositorio de desarrollo también es preciso instalar funcionalidades adicionales de ROS. Toda esta configuración puede consultarse con más detalle en el apéndice \ref{chapter:configuracion_sistema}.

\section{Arquitectura}
Esta sección tiene como objetivo plantear la arquitectura general utilizada en el robot, las comunicaciones con el resto del hardware y con los nodos que proporcionan la información necesaria para que el robot sea totalmente autónomo.

\subsection{Arquitectura del sistema}

A nivel de hardware utilizado en el proyecto, como es el propio robot, los sensores y el ordenador de a bordo, el sistema se estructura de la siguiente manera:

\begin{enumerate}[i)]
\item  Robot Pioneer 3 AT: Este es el robot mencionado anteriormente, el cual debe ser configurado para acceder al puerto serie RS-232 de su placa controladora. Esto nos permite conectarnos con el firmware ARCOS y comunicarnos a través de la librería ARIA. De esta forma se controlan los motores y se obtiene el valor de los encoders de la odometría.

\item Sensores: Tanto el sensor Kinect como el sensor láser sea alimentan mediante las baterías del robot y se comunican con el ordenador de a bordo a través del puerto USB y ethernet respectivamente.

\item Ordenador Intel NUC: Es el ordenador de a bordo encargado de ejecutar ROS y realizar todo el procesamiento necesario. Está equipado con el sistema operativo Ubuntu 14.04 por ser la última versión estable disponible a fecha de la entrega del proyecto. Se conecta al microcontrolador del robot  mediante un convertidor RS-232 a USB, al sensor láser y al sensor Kinect. Además el sistema contiene unos altavoces externos que se conectan por su salida específica.

\item Ordenador externo: Como se ha mencionado anteriormente, un ordenador externo opcional equipado con ROS podrá utilizarse para realizar tareas de supervisión a través de RViz y para realizar la teleoperación del robot vía TCP/IP en ROS.
\end{enumerate}

\subsection{Estructura software del proyecto}

El proyecto está estructurado siguiendo la filosofía de "paquetes" desarrollados en ROS. Los paquetes se compilan dentro de un entorno de trabajo tipo Catkin \cite{catkin} que se encarga de compilar correctamente a través de CMake todos los ejecutables y de realizar el enlazado correctamente.

En el directorio raíz del proyecto por tanto, encontraremos los paquetes necesarios para que el sistema funcione:

\begin{figure}[htp]
\centering
\includegraphics[width=0.8\textwidth]{figuras/proyecto_carpetas.png}
\caption{Estructura del proyecto}
\label{fig:proyecto_carpetas}
\end{figure}

Las carpetas de color azul son paquetes desarrollados por terceros que no vienen integrados por defecto en ROS, mientras que los paquetes ROS de desarrollo propio en este proyecto son los indicados en color naranja. El procedimiento para utilizarlos es clonar su repositorio en GitHub e incluirlos como submodulos dentro de nuestro proyecto.

A continuación se realiza una breve descripción de cada uno:
\begin{itemize}
\item  \textit{audio\_common}: Agrupa todas las funcionalidades para reproducir sonidos y voz sintetizada.

\item \textit{depthimage\_to\_laserscan}: Nodo que realiza la conversión del tipo de dato Pointcloud2 a LaserScan mediante el análisis de imagen y la profundidad de la nube de putnos. Configurable mediante parámetros.

\item \textit{freenect\_stack}: Agrupa los nodos controladores del sensor Kinect basados en libfreenect y transforma la información para que se accesible mediante ROS.

\item \textit{LMS1xx}: Nodo para la conexión con los sensores Láser Sick De la familia LMS100 a través de puerto ethernet.

\item \textit{p2os}: Agrupa utilidades y nodos para conectarse con los robots de la familia Pioneer, en especial Pioneer 3 AT y 3 DX. Ofrece modelos 3D de cada robot y algunos parámetros de configuración de los robots.

\item \textit{pocketsphinx}: Utilidad para el reconocimiento de voz mediante cualquier tipo de micrófono.

\item \textit{rosaria}: Interfaz de comunicación ROS con la librería Aria para el control de los motores del robot y la lectura de los encoders. Ofrece parámetros de calibración de los encoders y acceso al array de ultrasonidos del robot (funcionalidad no incorporada en el robot utilizado para este proyecto).

\item \textit{turtlebot}, \textit{turtlebot\_apps} y \textit{turtlebot\_msgs}: Paquetes que agrupan funcionalidades para el robot \textit{Turtlebot}, usadas en este caso en nuestro desarrollo.
\end{itemize}

Los paquetes ROS de desarrollo propio son los siguientes:

\begin{itemize}
\item El paquete \textit{navigation\_goals} es un nodo que realiza navegación a través de puntos establecidos de modo que se puedan programar rutas a seguir por el robot.

\item El paquete \textit{pioneer\_utils} es donde se encuentra el desarrollo principal de este proyecto y se describirá en detalle a continuación.

\begin{figure}[htp]
\centering
\includegraphics[width=0.8\textwidth]{figuras/pioneer_utils_carpetas.png}
\caption{Estructura de carpetas del paquete pioneer\_utils}
\label{fig:pioneer_utils_carpetas}
\end{figure}
\end{itemize}

Como cualquier paquete en ROS, disponemos de un archivo \textit{CMakeLists.txt} y un \textit{package.xml}, donde se indican los objetivos a compilar y las librerías adicionales para el enlazado así como las dependencias respectivamente.

En el directorio del paquete \textit{pioneer\_utils} encontramos:

\begin{itemize}
\item  \textit{follower}: Archivos de configuración para utilizar la funcionalidad follower del robot Turtlebot en el Pioneer 3 AT.

\item \textit{gazebo}: Especificaciones necesarias para ejecutar Gazebo. Incluye un modelo en tres dimensiones del robot Pioneer 3 AT y los sensores del mismo tipo que el utilizado en la realidad. También incluye \textit{launchfiles} para realizar la navegación con diferentes mapas.

\item \textit{main}: Launchfiles de las aplicaciones principales que incorpora el robot como el nodo \textit{endurance\_test}.

\item \textit{maps}: Información sobre mapas guardados realizados con la funcionalidad de \textit{slam\_gmapping}.

\item \textit{navigation}: Archivos y ajustes necesarios para realizar navegación del robot con y sin mapa (global navigation o local navigation).

\item \textit{panorama}: Archivos de configuración para utilizar la funcionalidad \textit{panorama} del robot \textit{Turtlebot} en el nuestro.

\item \textit{rviz}: Configuraciones preguardadas para rviz.

\item \textit{sensors}: Archivos de configuración para tener acceso a toda la información del hardware y de los sensores que se utilizan.

\item \textit{src}: Carpeta donde se incluye el código fuente en C++ o Python de los nodos de teleoperación, test de navegación y navegación estimada (Dead reckoning).

\item \textit{voice\_audio}: Archivos de configuración para el nodo de reconocimiento de voz y sonido, diccionarios de palabras y pronunciación.
\end{itemize}
