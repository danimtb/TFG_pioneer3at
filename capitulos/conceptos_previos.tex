\chapter{Conceptos previos}

\section{Entorno ROS}

La versión del software ROS utilizada para el desarrollo del proyecto ha tratado de ser siempre la más actual posible, ya que eso nos asegura mantener la compatibilidad en futuros trabajos y que el software esté actualizado.

La versión utilizada fue ROS Indigo Igloo desde el comienzo del proyecto, bajo el sistema operativo Ubuntu 14.04. A fecha de entrega del proyecto existe una versión más actualizada del software ROS, sin embargo se desestimó su uso debido a que aún no era una versión estable y algunos paquetes no se encontraban disponibles para tal versión.

ROS realiza funciones similares a un sistema operativo, como la comunicación e interacción entre diferentes procesos, la distribución en hilos, comunicación distribuida entre máquinas, abstracción del hardware, control a bajo nivel...

ROS también proporciona herramientas y librerías para crear código, compilarlo y ejecutarlo en diferentes máquinas.

El concepto más importante dentro de ROS son los nodos, que no son más que un proceso que se ejecuta y conecta al proceso principal, llamado máster, para comunicarse con otros nodos. Existen diferentes conceptos rostopics, rosservices, nodelets... que serán explicados en el siguiente punto.

\subsection{Funcionamiento de ROS}

Como hemos dicho, en ROS las acciones del robot se llevan a cabo mediante la interacción de diferentes nodos que se conectan entre sí en forma de grafo. Cada nodo se conecta a un nodo principal llamado máster (roscore) que se encarga de abrir un canal de comunicación entre cada nodo o proceso.

En la figura \ref{fig:nodos_conectados} vemos un ejemplo para el robot simulado "turtlesim", al cual le envía comandos el nodo de teleoperación "teleop\_turtle" y ambos publican información a través del nodo "rosout".

\begin{figure}[htp]
\centering
\includegraphics[width=0.8\textwidth]{figuras/rosgraph.png}
\caption{Grafo de ejemplo con nodos conectados}
\label{fig:nodos_conectados}
\end{figure}

Teniendo esta estructura en mente, es conveniente definir algunos conceptos sobre los que trabaja ROS **referencia**:

\begin{itemize}
\item Nodos (nodes): Los nodos son procesos que realizan algún tipo de cómputo. Un robot basado en ROS precisará de varios nodos ejecutándose al mismo tiempo e intercambiándose información.

\item Máster (master): El nodo ROS master proporciona una vía comunicación para el intercambio de mensajes y un registro de cada nodo. También dispone de un registro de parámetros a los que pueden tener acceso cualquiera de los nodos.

\item Mensajes (messages): Los nodos se comunican unos con otros a través de mensajes. La estructura de estos mensajes puede definirse por el usuario y contener diferentes tipos de datos.

\item Topics: Los mensajes son transmitidos a través de un sistema de publicación / subscripción. Un nodo envía un mensaje publicándolo en cierto topic y otro nodo puede leer el mensaje si se suscribe.

\item Servicios (services): Los servicios son similares a los topics pero son mucho más apropiados para realizar comunicaciones del tipo solicitud / respuesta.

\item Bags: El concepto de "bag" puede entenderse como un almacen de mensajes. Los mensajes de cierto topic pueden guardarse para analizar los datos más tarde o reproducir cierta situación.
\end{itemize}

\begin{figure}[htp]
\centering
\includegraphics[width=0.8\textwidth]{figuras/esquema_ros.png}
\caption{Esquema del funcionamiento de ROS}
\label{fig:esquema_ros}
\end{figure}

A nivel de sistema de ficheros ROS se estructura de la siguiente forma:

\begin{itemize}
\item Paquetes (packages): Es la unidad principal de organización de software en ROS. Un paquete puede contener nodos, tipos de datos, archivos de configuración.

\item Metapaquetes (metapackages): Sirven para representar un conjunto de paquetes que tienen realción entre sí.

\item Package manifests: Son archivos de tipo xml donde se indican los metadatos de un paquete, como su nombre, su versión, una descripción, licencia, dependencias de otras librerías o paquetes...

\item Repositorios: Normalmente, para distribuir los paquetes en ROS se utilizan repositorios bajo un sistema de control de versiones.

\item Tipos de mensajes: Son archivos con la estructura de un
tipo de mensaje (MiMensaje.msg)

\item Tipos de servicios: Son archivos con la estructura de un tipo de servicio tanto para los datos de solicitud como los de respuesta (MiServicio.srv)
\end{itemize}

Tmabién es necesario conocer algunos tipos de archivos y su uso dentro de ROS para comprender el trabajo de este proyecto:

\begin{itemize}
\item Launchfiles: ROS ofrece la herramienta "roslaunch" para ejecutar varios nodos con un solo comando y configurar sus parámetros. Es una forma cómoda de organizar la puesta en marcha de todos los nodos y enlazar unos launchfiles con otros. Los archivos suelen tener la extensión \textit{.launch} y su estructura es similar a la sintaxis xml **referencia**.

\item yaml: Es un formato de serialización de datos legible para los humanos de tal modo que se enfoca más en los datos que en el marcado de los archivos. Su formato es \textit{.yaml} y se utiliza para definir parámetros en cada nodo.

\item xacro: Son archivos que combinan el lenguaje xml con macros de tal modo que podemos mantener los archivos más legibles y ordenados **referencia**. Estos archivos se utilizan principalmente para definir un modelo de nuestro robot en URDF (Unified Robot Description Format) y su extensión es \textit{.xacro}.

\item URDF (Unified Robot Description Format): Es un tipo de formato utilizado para describir la estructura de un objeto en forma de eslabones y articulaciones de distinto tipo **refrencia**. En ROS se utilizan para generar modelos del robot en Gazebo y en RViz y conocer de manera gráfica el estado de los eslabones del robot. La extensión de estos archivos es \textit{.urdf}.

\item gazebo: Los archivos \textit{.gazebo} definen características concretas para utilizar robots definidos mediante URDF. Estos archivos permiten desacoplar las características utilizadas en Gazebo del modelo original.

\item world: Los archivos \textit{.world} definen en sintaxis xml mundos virtuales para cargar en el simulador Gazebo. Pueden definirse los objetos a incorporar, las luces y la posición del punto de vista.
\end{itemize}

Por último, cabe destacarr la importancia de uno de los paquetes integrados en ROS que más beneficios nos aporta, el paquete de transformadas \textit{tf}.

\textit{tf} **referencia** es uno de los paquetes de geometría dentro de ROS que nos permite realizar transformadas de los datos a un sistema de coordenadas concreto, estos sistemas de coordenadas son denominados como \textit{frames}. Muchas funcionalidades de ROS se basan en este tipo de transformadas para realizar los cálculos matemáticos oportunos así como para determinar la posición de nuestro robot y sus articulaciones.

\begin{figure}[htp]
\centering
\includegraphics[width=0.6\textwidth]{figuras/frames.png}
\caption{Frames utilizados en el robot PR2}
\label{fig:esquema_ros}
\end{figure}

\subsection{Configuración de ROS}
Para la instalación de ROS es necesario seguir ciertos pasos bien explicados en la wiki de su página **referencia**. Al ser un sistema fuertemente basado en sistemas UNIX y con mayor soporte para Ubuntu, las instalaciones se realizan principalmente a través de herramientas como apt (Advanced Packaging Tool) **referencia**.

Existen diferentes instalaciones de ROS dependiendo de si precisamos de todas sus herramientas y utilidades o no, ya que por ejemplo no tendría sentido instalar herramientas de interfaz gráfica en un robot que dispone de entorno gráfico. Para el ordenador de abordo del robot utilizamos la versión completa del software.

\begin{code}[htp]
\begin{lstlisting}[style=consola]
$ sudo apt-get install ros-indigo-desktop-full
\end{lstlisting}
\caption{Mandato de consola para instalar la versión completa de ROS Indigo.}
\end{code}

Añadimos nuestra variable de entorno para que el sistema reconozca todas herramientas de ROS:

\begin{code}[htp]
\begin{lstlisting}[style=consola]
$ source /opt/ros/indigo/setup.bash
\end{lstlisting}
\caption{Source al setup de ROS Indigo}
\end{code}

Para el desarrollo dentro de ROS se utiliza el entorno de desarrollo Catkin **referencia**, que facilita el enlazado y compilación de los paquetes. para ello es necesario tenerlo instalado y crear un entorno de desarrollo:

\begin{code}[htp]
\begin{lstlisting}[style=consola]
$ sudo apt-get install ros-indigo-catkin
$ mkdir -p ~/catkin_ws/src
$ cd ~/catkin_ws/src
$ catkin_init_workspace
\end{lstlisting}
\caption{Instalación y workspace de Catkin}
\end{code}

Y a continuación es necesario incluir nuestro directorio de desarrollo para que sea reconocido:

\begin{code}[!htp]
\begin{lstlisting}[style=consola]
$ cd ~/catkin_ws
$ source devel/setup.bash
\end{lstlisting}
\caption{Source al setup de nuestro entorno Catkin}
\end{code}

A partir de este punto podríamos crear nuestros propios paquetes utilizando las funcionalidades de ROS **referencia \url{http://wiki.ros.org/catkin/Tutorials/CreatingPackage}.

\subsection{Configuración de los paquetes ROS}

Los paquetes ROS son funcionalidades desarrolladas por terceros que se integran en el sistema ROS y que son transferibles de un robot a otro.

Los paquetes ROS incorporan un archivo \textit{CMakeLists.txt} para la compilación de los nodos que se hayan desarrollado así como sus mensajes y un archivo Package Manifest (\textit{package.xml}), como hemos indicado anteriormente.

Para el desarrollo de este proyecto es necesario clonar el repositorio GitHub \hypersetup{urlcolor=black} \href{https://github.com/danimtb/pioneer3at_ETSIDI}{\textit{ pioneeer3at\_ETSIDI}} \hypersetup{urlcolor=blue}en nuestra carpeta \textit{$\sim$/catkin\_ws/src}. Este repositorio contiene todos los paquetes necesarios en nuestro entorno:

\begin{code}[htp]
\begin{lstlisting}[style=consola]
$ cd ~/catkin_ws/src
$ $ git clone --recursive https://github.com/danimtb/pioneer3at_ETSIDI.git .
\end{lstlisting}
\hypersetup{urlcolor=black}
Fuente: \href{https://github.com/danimtb/pioneer3at_ETSIDI}{\textit{https://github.com/danimtb/pioneer3at\_ETSIDI}}
\hypersetup{urlcolor=blue}
\caption{Clonado del repositorio \textit{pioneer3at\_ETSIDI}}
\end{code}

Junto con el repositorio de desarrollo también es preciso instalar funcionalidades adicionales de ROS. Toda esta configuración puede consultarse con más detalle en el apéndice \ref{chapter:configuracion_sistema}.

\section{Arquitectura}
Esta sección tiene como objetivo plantear la arquitectura general utilizada en el robot, las comunicaciones con el resto del hardware y con los nodos que proporcionan la información necesaria para que el robot sea totalmente autónomo.

\subsection{Arquitectura del sistema}

A nivel de hardware utilizado en el proyecto, como es el propio robot, los sensores el ordenador de abordo el sistema se estructura de a siguiente manera:

\begin{enumerate}[i)]
\item  Robot Pioneer 3 AT: Este es el robot mencionado anteriormente, el cual debe ser configurado para acceder al puerto serie RS-232 de su placa controladora. Esto nos permite conectarnos con el firmware ARCOS **referencia** y comunicarnos a través de la librería ARIA. De esta forma controlamos los motroes y podemos leer el valor de los encoders de la odometría.

\item Sensores: Tanto el sensor Kinect como el sensor láser irán alimentados a través de las baterías del robot y se comunicarán con el ordenador de abordo a través de puerto USB y ethernet respectivamente.

\item Ordenador Intel NUC: Será el ordenador de abordo encargado de ejecutar ROS y realizar todo el procesamiento necesario. Irá equipado con el sistema operativo Ubuntu 14.04 por ser la última versión estable disponible a fecha de la entrega del proyecto. Irá conectado al robot mediante un convertidor RS-232 a USB, el sensor láser se comunica vía ethernet y el sensor Kinect a través de puerto USB igualmente. También se conectará el audio al altavoz integrado del robot.

\item Ordenador externo: Como se ha mencionado anteriormente, un ordenador externo opcional equipado con ROS podrá utilizarse para realizar tareas de a supervisión inalámrica a través de RViz y para realizar la teleoperación del robot vía TCP/IP integrado en ROS.
\end{enumerate}

\subsection{Arquitectura del proyecto}

El proyecto está estructurado siguiendo la filosofía de "paquetes" desarrollados en ROS. Los paquetes se compilan dentro de un entorno de trabajo tipo Catkin **REFERENCIA** que se encarga de compilar correctamente a través de CMake **referencia** todos los ejecutables y de realizar el enlazado correctamente.

En el directorio raíz del proyecto por tanto, encontraremos los paquetes necesarios para que el sistema funcione:

\begin{figure}[htp]
\centering
\includegraphics[width=0.8\textwidth]{figuras/proyecto_carpetas.png}
\caption{Estructura del proyecto}
\label{fig:proyecto_carpetas}
\end{figure}

Las carpetas de color azul son paquetes desarrollados por terceros que no vienen integrados por defecto en ROS. El procedimiento para utilizarlos es clonar su repositorio en github e incluirlos como submodulos dentro de nuestro proyecto.

A continuación se realiza una breve descripción de cada uno:
\begin{itemize}
\item  audio\_common: Agrupa todas las funcionalidades para reproducir sonidos y voz sintetizada.

\item depthimage\_to\_laserscan: Nodo que realiza la conversión del tipo de dato Pointcloud2 a laserscan mediante el análisis de imagen. Configurable mediante parámetros.

\item freenect\_stack: Agrupa los nodos controladores del sensor Kinect basados en libfreenect y tranfroman toda la información a la interfaz de ROS.

\item LMS1xx: Nodo para la conexión con los sensores Láser Sick De la familia LMS100 a través de puerto ethernet.

\item p2os: Agrupa utilidades y nodos para conectarse con los robots de la familia Pioneer, en especial Pioneer 3 AT y 3 DX. Ofrece modelos 3D de cada robot y algunos parámetros de configuración de los robots.

\item pocketsphinx: Utilidad para el rconocimiento de voz mediante cualquier tipo de micrófono.

\item rosaria: Interfaz de comunicación ROS con la librería Aria para el control de los motores del robot y la lectura de los encoders. Ofrece parámetros de calibración de los encoders y acceso al array de ultrasonidos del robot (funcionalidad no incorporada en el robot utilizado para este proyecto).

\item turtlebot, turtlebot\_apps y turtlebot\_msgs: Paquetes que agrupan funcionalidades para el robot Turtlebot, usadas en este caso en nuestro desarrollo.
\end{itemize}

Los paquetes ROS de desarrollo propio en este proyecto son los indicados en color naranja.

El paquete navigation\_goals es un nodo que realiza navegación a través de puntos establecidos de modo que se puedan programar rutas a seguir por el robot.

El paquete pioneer\_utils es donde se encuentra el desarrollo principal de este proyecto y se describirá en detalle a continuación.

\begin{figure}[htp]
\centering
\includegraphics[width=0.8\textwidth]{figuras/pioneer_utils_carpetas.png}
\caption{Estructura de carpetas del paquete pioneer\_utils}
\label{fig:pioneer_utils_carpetas}
\end{figure}

Como cualquier paquete en ROS, disponemos de un archivo CMakeLists.txt y un package.xml, donde se indican los objetivos a compilar y las librerías adicionales para el enlazado así como las dependencias respectivamente.

En cada carpeta encontramos:

\begin{itemize}
\item  follower: Archivos de configuración para utilizar la funcionalidad follower del robot Turtlebot en el nuestro.

\item gazebo: Configuraciones necesarias para ejecutar Gazebo utilizando un modelo del robot Pioneer 3 AT y sus sensores del mismo tipo que el utilizado en la realidad. Se incluyen launchfiles **OJO** para realizar la navegación con diferentes mapas.

\item main: Launchfiles de las aplicaciones principales que incorpora el robot **COMPLETAR**.

\item maps: Mapas guardados realizados con la funcionalidad de slam\_gmapping.

\item navigation: archivos y ajustes necesarios para realizar navegación del robot con y sin mapa (global navigation o local navigation).

\item panorama: Archivos de configuración para utilizar la funcionalidad panorma del robot Turtlebot en el nuestro.

\item rviz: Configuraciones preguardadas para rviz.

\item sensors: Archivos de configuración para tener acceso a toda la información del hardware y los sensores que se utilizan.

\item src: Carpeta donde se incluye el código fuente en C++ o Python de los nodos de teleoperación, test de navegación y navegación por estima (Dead reckoning).

\item voice\_audio: Archivos de configuración para el nodo de reconocimiento de voz y sonido, diccionarios de palabras y pronunciación.
\end{itemize}
