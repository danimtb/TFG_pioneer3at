\chapter{Implementación del sistema}\label{chapter:implementacion}

Este capítulo describe los cambios, ajustes y modificaciones que, basados en la información anterior expuesta, las características de ROS y el hardware del que disponemos, se han realizado para alcanzar los objetivos del proyecto.

\section{Configuraciones hardware}
Como ya se ha descrito, la navegación se basa en el sensor Kinect pero también se ha considerado integrar el sensor láser debido a la valiosa información que aporta y su disponibilidad.

Por ello, el robot deberá llevar incorporados estos sensores proporcionándoles alimentación y una interfaz de conexión adecuada.

\subsection{Pioneer 3 AT}
El robot Pioneer 3 AT de Adept Mobile Robots es la base de la plataforma robótica. El modelo disponible en el laborarotio de la Escuela Técnica Superior de Ingeniería y Diseño Industrial llevaba incorporado un ordenador de tipo **ORDENADOR PIONEER**. También, al comienzo de este proyecto ya existían algunas adaptaciones como la incorporación de un altavoz frontal, acceso a los puestos USB del ordenador interno y conexión para el sensor láser.

IMAGEN ROBOT ESTADO INICIAL.

El robot había sido utilizado anteriormente mediante el software MRCore en el proyecto **PROYECTO DE ALEJANDRO** y el sistema operativo del ordenador interno era Ubuntu Server 10.

Para integrar la versión Indigo de ROS lo más recomendable era partir de la versión estable más actualizada de Ubuntu, por lo que se sustituyó el sistema operativo por Ubuntu 14.04 LTS en su versión de escritorio.

Una vez integrado el sistema operativo, la primera toma de contacto con el robot fue a partir de la librería Aria **referencia** para controlar el movimiento de los motores y comprobar que el robot se encontraba en buen estado.

**Añadir el puerto al grupo de dialout**

A continuación, tras instalar ROS Indigo, se procedió a las pruebas mediante el paquete Rosaria de ROS. La conexión con el microcontrolador de la placa de motores fue exitosa y se comprobó que los valores de la odometría también funcionaban.

**cambiar el puerto de conexion*?*


Llegados a este punto, ya disponíamos del robot preparado para realizar las primeras pruebas.

\subsection{Sensor Láser}
El sensor láser Sick ya había sido integrado en un proyecto anterior y sus conexiones de alimentación y datos vía Ethernet ya estaban preparadas para utilizarlo.

Para conectarlo a través del puerto Ethernet fue necesario ajustar su dirección IP a través del software del fabricante y ajustar la IP del ordenador del robot Pioneer (más información en el apéndice **TAL**).

El agarre mecánico del sensor se dejó tal y como había sido utilizado en ocasiones anteriores, situado en la parte frontal agarrado mediante un par de tornillos al chasis con tuercas de palometa para su fácil manipulación.

**Imagen del sensor láser en el robot**.

El sensor láser se conecta a la interfaz ROS mediante el paquete LMS1xx tal y como se describió en el apartado \ref{subsection:sicklms100}.

\subsection{Sensor Kinect}
La integración del sensor Kinect fue relativamente sencilla debido a que las entradas de los puestos USB del ordenador habían sido cableadas previamente. La adaptación a realizar era sobre la parte de alimentación, ya que este sensor trabaja a una tensión de 12 voltios.

En el manual del robot se encuentra una descripción detallada de la placa de alimentación a la cual pueden conectarse diferentes periféricos. Esta placa ofrece tomas de conexión de 5 voltios controlados por unos botones auxiliares y tomas de 12 voltios (ver apéndice **TAL**).

El sensor Kinect dispone de un adaptador USB, preparado para trabajar con la videoconsola XBOX 360, el cual suministra 12 voltios mediante un transformador conectado a una toma de corriente alterna de 220v e incorpora los cables de datos del propio sensor Kinect.

**Esquema conexion usual**.

Para integrar el sensor Kinect en el robot, se cortó el cable de alimentación del cable adaptador y se soldaron unas clavijas tipo Jack **REVISAR** macho-hembra para conectar el adaptador directamente a los 12 voltios de la placa del robot. También se realizaó lo oportuno en el adaptador de corriente, para poder usar el sensor Kinect de la manera habitual.

\begin{figure}[!htp]
\centering
\includegraphics[width=\textwidth]{figuras/adaptador_kinect.png}
\includegraphics[width=\textwidth]{figuras/cable_kinect.png}
\caption{Adaptación de cables para la alimentación del sensor Kinect}
\label{fig:cables_kinect}
\end{figure}

Para anclar el sensor Kinect al robot se optó por situarlo en la parte superior del sensor Láser, para lo cual se diseñó una pieza que encajase en la base de la Kinect y en el sensor láser (figura **REF**).

**Imagen del diseño 3D**

El sensor Kinect se conecta a la interfaz ROS mediante el paquete freenect\_stack tal y como se describió en el apartado \ref{subsection:kinect}.

\subsection{Primera configuración hardware}
La primera configuración del robot consistió en ambos sensores situados en la parte frontal del mismo. Los sensores de encontraban colocados de manera vertical otro, de tal forma que no existieran interferencias entre uno y otro.

\begin{figure}[!htp]
\centering
\includegraphics[width=\textwidth]{figuras/primera_configuracion.jpg}
\caption{Primera configuración hardware del robot}
\label{fig:primera_configuracion}
\end{figure}

De esta forma conseguíamos una vista frontal despejada y contábamos con la información del láser para detectar obstáculos laterales.

\subsubsection{Primera configuración del sistema}
El ordenador interno corría todos los nodos de ROS, de modo que se disponía de la información de los sensores, el control sobre los motores y la lectura de la odometría para realizar las primeras pruebas con el paquete de navegación de ROS (Sección \label{section:navigation_stack}).

Sin embargo, la primera implementación con los primeros ajustes a nuestro hardware de los sensores no fue posible debido a la sobrecarga de la CPU del ordenador interno del robot Pioneer y a problemas de memoria en la ejecución de nodos como AMCL.

\subsubsection{Segunda configuración del sistema}
La siguiente opción fue utilizar un ordenador externo que realizase los cálculos de navegación y enviase al robot las consignas de movimiento a través de una red WLAN. Esta idea no era la solución más ideal, ya que desde el principio la idea era que el robot fuese lo más autónomo posible sin depender de una infraestructura, sin embargo era una posibilidad directa que no suponía mucho esfuerzo.

**esquema configuración**

Gracias a la filosofía de ejecución distribuida de nodos de ROS, ejecutar nodos en máquinas diferentes y compartir la información entre procesos es una tarea sencilla. Para configurarlo, tan solo es necesario indicar a las máquinas la IP del nodo master. De esta forma, los nodos que se ejecuten en cada una de las máquinas tratarán de realizar la comunicación a través de IPs dentro de la misma red.

Este ajuste fue puesto en marcha utilizando un ordenador portátil con suficiente capacidad de procesamiento y memoria como para ejecutar la navegación, sin embargo aparecieron algunos inconvenientes.

El primero de ellos fueron las direcciones IP en el ordenador interno del Pioneer.

\textbf{Problemas con el sensor Láser: LM1xx}\\
Debido a que el sensor láser se conecta vía Ethernet a este ordenador, el nodo LMS1xx debe obtener información a través de la IP del láser y enviarla a través del adaptador Wifi a la IP del nodo máster. El problema residía en que el nodo se saturaba al tener que lidiar con ambas interfaces de conexión y provocaba su detención.

Tras varias consultas a Clearpath Robotics a través de su repositorio de GitHub y preguntas en el foro ROS Answers **Enlaces de referencia**, la solución no estaba implementada en código y lo más inmediato era hacer un bridge en el ordenador del Pioneer 3 AT entre la interfaz Ethernet y la Wifi.

Los resultados de esta solución no fueron satisfactorios ya que el comportamiento era el mismo: el nodo LMS1xx se saturaba e interrumpía a los pocos minutos de su ejecución.

Trantando de resolver este problema, se hicieron pruebas generando una red Wifi Ad-hoc desde el ordenador del robot, a la cual se conectaba el ordenador externo. Los resultados fueron buenos siempre y cuando las IPs del nodo master y del sensor Láser se encontrasen en el mismo subrango **revisar nomenclatura**.

En la implementación final del sistema esta solución se sigue utilizando para conectarse desde un ordenador externo al ordenador que incorpora el robot Pioneer.

**OJOOOO continua seccion**

Una vez se pudo conectar el ordenador externo, la ejecución del nodo de navegación era la correcta y las consignas de movimiento se enviaban correctamente al robot, pudiendo realizar las primeras pruebas de navegación autónoma.

**Imagen primeras navegaciones**

Sin embargo en ocasiones la recepción y envío de datos era demasiado alta y esto provocaba que existiese mucho retraso en la comunicación, haciendo que el robot reaccionase tarde para esquivar los obstáculos y el control del robot fuera impracticable.

\subsubsection{Tercera configuración del sistema}
Finalmente se optó por montar un ordenador más potente en el robot, para lo cual se utilizó un portátil externo al que se conectaba tanto e sensor Kinect como el sensor Láser y se utilizaba un convertidor de puesto USB a puerto serie RS-232 para controlar el movimiento del robot y leer la odometría. El ordenador del robot quedaba sustituido y así se mantuvo hasta la versión final.

**imagen del robot con el portátil**

Llegados a este punto, ahora sí disponíamos de la plataforma robótica completa sobre la que trabajar en la navegación del robot. Las primeras pruebas fueron satisfactorias, logrando correr todos los nodos en el portátil, el cual se incorporó de manera provisional al robot por medio de unos agarres realizados con una impresora 3D.

**imagen de los agarres**

\subsection{Segunda configuración}

La segunda configuración hardware vino dada tras las pruebas satisfactorias con l
\subsubsection{Configuración del sistema final}
\textbf{Intel NUC}

\section{Navegación}
\subsection{Sensores}
\subsection{Navegación con mapa}
\subsection{Navegación reactiva}
\section{Nodo de navegación por puntos}
\section{Nodo de comandos por voz}
\subsection{Reconocimiento de comandos de voz}
\subsection{Feedback mediante text-to-speech}

\section{Nodo de ejecución automática de nodos}
