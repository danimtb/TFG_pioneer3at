\chapter{Control a bajo nivel}

En este capítulo se realiza una primera aproximación al control del robot y a los nodos básicos que deben ejecutarse para controlarlo y acceder a la información de los sensores.

\section{Nodos Hardware}

Los nodos necesarios para el control del robot requieren el acceso a los motores y a la lectura de la odometría. También es necesario disponer de controladores para los dos sensores exteroceptivos utilizados y que su información se publique en tipos de datos reconocibles por ROS. Los nodos utilizados para estos dispositivos hardware se describen a continuación.

\subsection{Control del robot: Rosaria y p2os} \label{subsection:rosaria}

Como hemos indicado anteriormente, la librería que nos permite el acceso a la placa controladora de nuestro robot Pioneer es Aria. Esta librería, proporcionada por Adept Mobile Robots, permite realizar el control completo del robot y acceder a sus parámetros configurables.

Los paquetes disponibles en ROS para el control de los robots de la familia Pioneer son dos, por un lado tenemos \textit{rosaria} y por otro \textit{p2os}.

\begin{itemize}
\item \textbf{p2os} \cite{p2os} es un paquete que agrupa un conjunto de utilidades y nodos desarrollados para controlar el robot. Su característica principal es que accede de manera nativa a la placa controladora del robot por lo que no depende de la librería Aria. Además incorpora funcionalidades adicionales como modelos 3D de robot, simulación con Gazebo o la configuración de la navegación.

Sin embargo, \textit{p2os} no integra todas las funcionalidades a las que tiene acceso Aria, como es la reconfiguración de los parámetros de la odometría.

\item \textbf{rosaria} \cite{rosaria} es un nodo de interfaz entre ROS y Aria, por tanto incluye prácticamente todas las funcionalidades de esta. Podemos acceder a la calibración de los encoders de la odometría así como conectar con el simulador \textit{MobileSim} (ver sección \ref{MobileSim}).

\end{itemize}

El paquete que se ha utilizado para controlar el robot a bajo nivel es \textit{rosaria} debido a que integra funcionalidades adicionales importantes para el ajuste odométrico y a que el paquete \textit{p2os} se encuentra desactualizado en la versión ROS que utiliza.

A continuación se muestra el \textit{launchfile} para ejecutar el nodo \textit{RosAria}:

\begin{code}[htp]
\begin{lstlisting}[style=launch]
<launch>
<!-- Starting rosaria driver for motors and encoders -->
  <node name="rosaria" pkg="rosaria" type="RosAria" args="_port:=/dev/ttyUSB0">
  <rosparam>
      TicksMM: 166
      RevCount: 37350
      DriftFactor: 0
  </rosparam>
  <remap from="~cmd_vel" to="cmd_vel"/>
  </node>
</launch>
\end{lstlisting}
\caption[Launchfile para \textit{RosAria}]{Launchfile para \textit{RosAria}\footnotemark.}
\end{code}
\footnotetext{Fuente: \href{https://github.com/danimtb/pioneer3at_ETSIDI/blob/master/pioneer_utils/sensors/rosaria.launch}{\textit{ pioneer\_utils/sensors/rosaria.launch}}}

Como puede verse, los valores de la odometría son configurables (más información la subsección \ref{subsection:odometria} del apéndice).

Como cualquier nodo en ROS, el nodo \textit{RosAria} publica una serie de Topics y se suscribe a otros para poder intercambiar información entre otros nodos. En la tabla \ref{tabla_rosaria} se muestra parte de la API utilizada de \textit{RosAria}.

\begin{table}[!h]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{c c c}
& {\bf RosAria API} & \\
{\bf Topics suscritos} & {\bf Mensaje} & {\bf Descripción}\\ \hline
cmd\_vel & geometry\_msgs/Twist & Recibe los comandos de velocidad\\
{\bf Topics publicados} & {\bf Mensaje} & {\bf Descripción}\\
\hline
pose & nav\_msgs/Odometry & Publica la odometría\\
{\bf Parámetros} & {\bf Tipo} & {\bf Descripción}\\
\hline
port & string & Puerto serie del robot\\
TicksMM & float & Calibración de la odometría\\
DriftFactor & float & Rozamiento de la odometría\\
RevCount & float & Calibración de los encoders\\
{\bf Frames publicados} &  & {\bf Descripción}\\
\hline
base\_link & & Referencia base del robot\\
odom & & Referencia odométrica
\end{tabular}
}
\caption{API de \textit{rosaria} utilizada. Basado en \cite{rosaria}.}
\label{tabla_rosaria}
\end{table}

\subsection{Sensor Kinect}\label{subsection:kinect}

Para la puesta en marcha del sensor Kinect existen en ROS diferentes paquetes que utilizan una u otra librería de código en función de quién lo haya desarrollado.

Existen dos paquetes destinados al control del sensor Kinect:
\begin{itemize}

\item Por un lado tenemos \textit{openni\_kinect} \cite{opennikinect}, que utiliza los drivers de la librería OpenNI. Este paquete y en concreto los drivers del dispositivo han sido utilizados ampliamente tanto en desarrollos realizados con ROS como fuera de este entorno. Sus características principales son la total funcionalidad, aprovechamiento de toda la tecnología de este sensor y capacidad para monitorear la posición del esqueleto de una persona. Sin embargo, el soporte del paquete \textit{openni\_kinect} solo se mantuvo activo hasta a versión ROS Fuerte debido a la compra de PrimeSense, empresa creadora del sensor y miembro fundador del proyecto OpenNI, por la conocida marca de informática Apple \cite{appleprimesense}.

\item Por otro lado, gracias al gran desarrollo software llevado a cabo por la comunidad OpenSource, disponemos de los divers \textit{libfreenect} desarrollados por el proyecto OpenKinect \cite{openkinect} que trata de ofrecer una vía alternativa para controlar el sensor de Microsoft. Estos drivers se encapsulan y adaptan su interfaz a ROS a través del paquete \textit{freenect\_stack} \cite{freenect} el cual nos ofrece acceso tan solo a la imagen y la nube de puntos del sensor. Su integración no es completa, no dispone de características adicionales como el monitoreo de la posición de una persona, sin embargo su funcionamiento es correcto y está adaptado a ROS en su versión Indigo por lo que ofrece la posibilidad de integrarlo en nuestro sistema.

\end{itemize}


La comparación anterior denota que el software más adecuado para acceder a la nube de puntos del sensor Kinect es el paquete \textit{freenect\_stack}, por lo que éste ha sido el utilizado en este proyecto.

Al ser un paquete de terceros, debe clonarse desde su repositorio de código fuente e incorporarlo al entorno Catkin. La puesta en marcha del mismo es bastante inmediata haciendo uso de los \textit{launchfiles} que ofrece \textit{freenect\_launch} desde consola de la siguiente forma:

\begin{code}[htp]
\begin{lstlisting}[style=consola]
roslaunch freenect_launch freenect.launch
\end{lstlisting}
\caption[Launchfile para Kinect en el paquete \textit{freenect\_launch}]{Launchfile para Kinect en el paquete \textit{freenect\_launch}\footnotemark.}
\end{code}
\footnotetext{Fuente: \href{https://github.com/ros-drivers/freenect_stack/blob/master/freenect_launch/launch/freenect.launch}{\textit{freenect\_stack/freenect\_launch/launch/freenect.launch}}}

En la tabla \ref{tabla_freenect} se muestra parte utilizada de su API.

\begin{table}[!h]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{c c c}
& {\bf libfreenect\_stack API} & \\
{\bf Topics publicados} & {\bf Mensaje} & {\bf Descripción}\\
\hline
camera/depth/points & sensor\_msgs/PointCloud2 & Publica la nube de puntos\\
camera/depth/image\_raw & sensor\_msgs/Image & Imagen captada\\
camera/depth/camera\_info & sensor\_msgs/CameraInfo & Información de la cámara\\
{\bf Frames} &  & {\bf Descripción}\\
\hline
camera\_link & & Referencia base de Kinect\\
camera\_rgb\_frame & & Referencia cámara RGB\\
camera\_depth\_frame & & Referencia cámara IR\\
\end{tabular}
}
\caption{API de \textit{freenect\_stack} utilizada.}
\label{tabla_freenect}
\end{table}

\subsection{Sensor Láser Sick LMS100}\label{subsection:sicklms100}

Existe un amplio soporte en ROS para sensores láser de la marca Sick, entre los más populares se encuentra la familia Sick LMS200, que se utiliza en muchos desarrollos relacionados con la robótica móvil. La familia de sensores LMS200 utiliza una interfaz de comunicación en serie a través de puerto RS-232, sin embargo, la familia de dispositivos Sick LMS100 utiliza interfaz ethernet y requiere un tratamiento de datos diferente.

El láser Sick LMS100 ha sido integrado en ROS y utilizado en este proyecto ya que se había dado uso en proyectos anteriores \cite{herrero2013} y se consideró conveniente incorporarlo debido a su precisión y rango.

Para acceder al sensor Sick LMS100 se utiliza el paquete \textit{LMS1xx} desarrollado por Clearpath Robotics \cite{clearpath} que se basa en los drivers desarrollados en la librería \textit{libLMS1xx}\footnote{Repositorio software \textit{libLMS1xx}: \url{https://github.com/konradb3/libLMS1xx}}.

El paquete \textit{LMS1xx} consta de un solo nodo que se conecta a través de una IP indicada como parámetro. Para conectarse al sensor láser es necesario configurar el puerto del ordenador con una IP fija dentro del mismo rango que la IP del sensor, la puerta de enlace queda vacía y utilizamos la máscara de subred por defecto.

Seguidamente basta con indicar en el archivo \textit{launchfile} la IP del sensor.

\begin{code}[htp]
\begin{lstlisting}[style=launch]
<launch>
  <arg name="host" default="192.168.1.14" />
  <node pkg="lms1xx" name="lms1xx" type="LMS1xx_node">
    <param name="host" value="$(arg host)" />
  </node>
</launch>
\end{lstlisting}
\caption[Launchfile para el sensor Láser Sick LMS100]{Launchfile para el sensor Láser Sick LMS100\footnotemark.}
\end{code}
\footnotetext{Fuente: \href{https://github.com/clearpathrobotics/LMS1xx/blob/master/launch/LMS1xx.launch}{\textit{LMS1xx/launch/LMS1xx.launch}}}

Pueden precisarse algunos ajustes previos para ajustar la dirección IP del sensor y algunos de sus parámetros. Esto puede hacerse mediante la herramienta "SOPAS Engineering tool" ofrecida el fabricante. Estos ajustes pueden encontrarse en el apéndice de este trabajo (Sección \ref{subsection:sicklms100_apendice}).

La API de este nodo se muestra en la tabla \ref{tabla_lms1xx}.

\begin{table}[!h]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{c c c}
& {\bf LMS1xx API} & \\
{\bf Topics publicados} & {\bf Mensaje} & {\bf Descripción}\\
\hline
/scan & sensor\_msgs/LaserScan & Puntos láser\\
{\bf Parámetros} & {\bf Tipo} & {\bf Descripción}\\
\hline
host & string & Dirección IP del láser\\
{\bf Frames} &  & {\bf Descripción}\\
\hline
laser & & Centro del haz láser\\
\end{tabular}
}
\caption{API del nodo \textit{LMS1xx}.}
\label{tabla_lms1xx}
\end{table}


\subsection{Integración del hardware}\label{subsection:integracion_hardware}

Una vez se dispuso de todos los paquetes necesarios para poner en funcionamiento todo el hardware en el robot, era necesario integrar todos los nodos bajo una misma configuración y definir mediante transformadas la posición de los sensores en el robot.

A partir de un nuevo archivo \textit{launchfile} (Código \ref{code:pioneer3at-rosaria}) se enlanzan cada nodo con las configuraciones del hardware y se definen las transformadas estáticas entre cada uno de los \textit{frames}.

\pagebreak

\begin{code}[htp]
\begin{lstlisting}[style=launch]
<launch>

<!-- Launching p2os RobotModel -->
  <include file="$(find p2os_urdf)/launch/pioneer3at_urdf.launch"/>

<!-- Launching LMS1xx_node for laser Sick LMS100 via ethernet -->
  <include file="$(find pioneer_utils)/sensors/LMS1xx.launch"/>

<!-- start sensor-->
<include file="$(find freenect_launch)/launch/freenect.launch"/>

<!-- Launch kinect and depthimage_to_laser node -->
  <include file="$(find pioneer_utils)/sensors/kinect_to_laser_low.launch"/>

<!-- Launch kinect and depthimage_to_laser node -->
  <include file="$(find pioneer_utils)/sensors/kinect_to_laser.launch"/>

<!-- Starting rosaria driver for motors and encoders -->
  <include file="$(find pioneer_utils)/sensors/rosaria.launch"/>

  <node pkg="tf" type="static_transform_publisher" name="base_to_laser_broadcaster" args="-0.2 0 0.390 3.141592 0 0 base_link laser 1" />
  <node pkg="tf" type="static_transform_publisher" name="base_to_camera_broadcaster" args="0.020 0 0.375 0 0 0 base_link camera_link 1" />

</launch>
\end{lstlisting}
\caption[Launchfile creado para robot Pioneer 3 AT]{Launchfile creado para robot Pioneer 3 AT\footnotemark.}
\label{code:pioneer3at-rosaria}
\end{code}
\footnotetext{Fuente: \href{https://github.com/danimtb/pioneer3at_ETSIDI/blob/master/pioneer_utils/sensors/pioneer3at-rosaria.launch}{\textit{pioneer\_utils/sensors/pioneer3at-rosaria.launch}}}

Como resultado, se obtiene una relación entre cada sistema de referencia (\textit{frame}), lo cual permite realizar transformaciones de los datos entre cada uno de ellos. Esto también sirve para que el robot "sea consciente" de su configuración (Figura \ref{fig:frames-odom_base}).

\begin{figure}[htp]
\centering
\includegraphics[width=0.8\textwidth]{figuras/frames-odom_base.png}
\caption{Referencias \textit{frames} de la configuración del robot.}
\label{fig:frames-odom_base}
\end{figure}

\section{Nodo de teleoperación}

Uno de los primeros objetivos de este proyecto consiste realizar el control teleoperado del robot. Utilizando ROS y sus características para operar de manera distribuida en diferentes máquinas, esta tarea se vuelve inmediata para el usuario.

\subsection{Características distribuidas de ROS}
ROS trabaja en forma de procesos que se ejecutan de manera independiente y se comunican a través del nodo principal MASTER mediante el paso de mensajes. Ya que el nodo MASTER dispone de una dirección IP en la máquina que lo ejecuta, basta con indicar en el entorno ROS de cada máquina la dirección de este para que los nodos abran una comunicación con esa dirección IP.

El nodo MASTER en este caso se ejecutará en el ordenador Intel NUC del robot, por lo que realizará la función de servidor de datos de cada nodo.

Los pasos para configurar las máquinas bajo la misma red se describen con detalle en la guía \textit{ROS Network Setup} \cite{network-ros} y consisten en indicar en el sript \textit{.bashrc}\footnote{El script \textit{.bashrc} se ejecuta cada vez que se abre una nueva terminal en el ordenador.} los parámetros ROS\_IP y ROS\_MASTER\_URI.

ROS\_IP debe contener la IP de nuestra máquina en la red que esté operando y ROS\_MASTER\_URI la dirección \textit{http} correspondiente de la máquina donde se ejecute el nodo principal, especificando el puerto.

\begin{code}[htp]
\begin{lstlisting}[style=launch]
export ROS_IP=10.42.0.1
export ROS_MASTER_URI=http://10.42.0.1:11311
\end{lstlisting}
\caption{Líneas del archivo \textit{.bashrc} en el ordenador de a bordo Intel NUC.}
\end{code}

El procedimiento es el mismo en el caso del ordenador que va a servir como control remoto. En la sección \label{section:ordenador_externo} del apéndice se encuentra más información sobre la conexión de un ordenador externo.

\begin{code}[!htp]
\begin{lstlisting}[style=launch]
export ROS_IP=10.42.0.77
export ROS_MASTER_URI=http://10.42.0.1:11311
\end{lstlisting}
\caption{Ejemplo \textit{.bashrc} en un ordenador externo para realizar comunicación con el máster.}
\end{code}

\subsection{Implementación del nodo}

Gracias a las características de sistema distribuido, podemos desarrollar un nodo ROS que se conecte al Topic \textit{cmd\_vel} de \textit{RosAria} y publicar diferentes valores de velocidad en función de las teclas que se pulsen sin tener que preocuparnos por implementar un socket de comunicación.

El nodo que se ha desarrollado realiza una teleoperación básica del robot, publicando mensajes de velocidad fija. Se ha partido del nodo de teleoperación desarrollado en el paquete \textit{turtlesim} \cite{turtlesim} ya que este reacciona ante pulsaciones instantáneas de teclado y favorece el control del robot.

La API ROS de este nodo solo consta de un parámetro (\ref{tabla:teleop_p3at}), el Topic de comandos de velocidad al que se conecta, por lo que esto lo hace reutilizable en cualquier otro robot que opere con ROS.

\begin{table}[!h]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{c c c}
& {\bf teleop\_p3at API} & \\
{\bf Topics publicados} & {\bf Mensaje} & {\bf Descripción}\\ \hline
cmd\_vel & geometry\_msgs/Twist & Publica comandos de velocidad\\
\end{tabular}
}
\caption{API de teleop\_p3at}
\label{tabla:teleop_p3at}
\end{table}

La implementación del nodo se ha realizado en C++ y su principal característica es que toma las pulsaciones del teclado en modo \textit{raw} de tal modo que es detectada inmediatamente.

\begin{code}[htp]
\begin{lstlisting}[style=C++]
...
	// get the console in raw mode
	tcgetattr(kfd, &cooked);
	memcpy(&raw, &cooked, sizeof(struct termios));
	raw.c_lflag &=~ (ICANON | ECHO);
	// Setting a new line, then end of file
	raw.c_cc[VEOL] = 1;
	raw.c_cc[VEOF] = 2;
	tcsetattr(kfd, TCSANOW, &raw);
	puts("--------------Reading from keyboard-------------");
	puts("------------------------------------------------");
	puts("Use arrow keys to move Pioneer and SPACE to stop");


	while(!g_request_shutdown && ros::ok())
	{

		// get the next event from the keyboard

		if(read(kfd, &c, 1) < 0)
		{
			perror("read():");
			exit(-1);
		}
			
		switch(c)
		{
			case KEYCODE_L:
				vel.linear.x = 0;
				vel.linear.y=0;
...
\end{lstlisting}
\hypersetup{urlcolor=black}
Fuente: \href{https://github.com/danimtb/pioneer3at_ETSIDI/blob/master/pioneer_utils/src/teleop_p3at.cpp}{\textit{pioneer\_utils/src/teleop\_p3at.cpp}}
\hypersetup{urlcolor=blue}
\caption{Fragmento de código del nodo \textit{teleop\_p3at}.}
\label{code:teleop_p3at}
\end{code}





\section{Nodo de navegación estimada}

La navegación estimada, más conocida en inglés como Dead Reckoning \cite{deadreckoning}, es la capacidad para realizar navegación en un entorno basándonos solamente en la información que aportan los sensores de la odometría.

Es un método estimado de localización que se basa en la información de los encoders y no tiene en cuenta aspectos como el tipo de superficie, la inclinación, el rozamiento o incluso obstáculos que puedan frenar o modificar el desplazamiento del robot (a pesar de que sus ruedas giren).

Este nodo de navegación puede utilizarse para indicar al robot que avance cierta cantidad de metros y que realice giros a derecha o izquierda en un determinado ángulo siempre tomando como referencia la información aportada por la odometría.

Este nodo toma los valores de la odometría y envía comandos de velocidad para que realice el movimiento indicado. A continuación se muestra su API (Tabla \ref{tabla:moving_alone}).

\begin{table}[!h]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{c c c}
& {\bf moving\_alone API} & \\
{\bf Topics suscritos} & {\bf Mensaje} & {\bf Descripción}\\ \hline
pose & nav\_msgs/Odometry & Recibe la odmetría\\
{\bf Topics publicados} & {\bf Mensaje} & {\bf Descripción}\\ \hline
cmd\_vel & geometry\_msgs/Twist & Publica comandos de velocidad\\
{\bf Frames suscritos} &  & {\bf Descripción}\\
\hline
base\_link & & Referencia base del robot\\
odom & & Referencia odométrica
\end{tabular}
}
\caption{API del nodo \textit{moving\_alone}.}
\label{tabla:moving_alone}
\end{table}

El nodo \textit{moving\_alone} está desarrollado en la interfaz C++ y su uso se muestra función \textit{main}.

\begin{code}[htp]
\begin{lstlisting}[style=C++]
...
int main(int argc, char** argv)
{
	ros::init(argc, argv, "moving_alone");
	ROS_INFO("Moving alone started");
	ros::NodeHandle nh;
	MoveAlone moving_alone(nh);
	moving_alone.avanza(1.0f, 0.5f);
	moving_alone.gira(true, 90.0f, 0.2f);
	moving_alone.avanza(-0.5f, 0.1f);
	return 0;
}
\end{lstlisting}
\hypersetup{urlcolor=black}
Fuente: \href{https://github.com/danimtb/pioneer3at_ETSIDI/blob/master/pioneer_utils/src/moving_alone.cpp}{\textit{pioneer\_utils/src/moving\_alone.cpp}}
\hypersetup{urlcolor=blue}
\caption{Fragmento de código del nodo \textit{moving\_alone}.}
\label{code:moving_alone}
\end{code}